---
title: 链表2
date: 2019-07-31 19:30:00
tags: [算法, LeetCode]
categories: 算法
thumbnail: /img/LeetCode3.jfif
---

## 环形链表 II LeetCode#142

>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
说明：不允许修改给定的链表。
```
示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```
![LeetCode142Question1](LeetCode142Question1.png)
```
示例 2：
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。
```
![LeetCode142Question2](LeetCode142Question2.png)
```
示例 3：
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```
![LeetCode142Question3](LeetCode142Question3.png)
进阶：
你是否可以不用额外空间解决此题？

#### 1. 缓存法

该解法与 LeetCode 141 的解法一样，用缓存把每个节点缓存起来，然后不断遍历链表并判断节点是否已经存在，如果已经存在就返回该节点。
这种方法的缺点也明显，时间复杂度高，空间复杂度也高

```javascript
// arrary memory
const hasCycle = (head) => {
  if(head === null) {
    return false
  }
  const memory = []
  while (head !== null) {
    if (memory.indexOf(head) > -1) {
      return true
    }
    memory.push(head)
    head = head.next
  }
  return false
}
// set memory
const detectCycle = (head) => {
  if(head === null) {
    return head
  }
  // 用 set 模拟 hash table
  const memory = new Set()
  while (head !== null) {
    if (memory.has(head)) {
      return head
    }
    memory.add(head)
    head = head.next
  }
  return head
}
```

#### 2. Floyd 算法

该解法是在 LeetCode 141 双指针法的基础上变化而来的。如果不看答案，我是想不出这种纯数学的解法的。

分为两个阶段

* 判断是否有环
* 找出环入口（这里是一个比较巧妙的数学解法）

具体证明 -> [LeetCode 142 Floyd 算法](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/)

```javascript
const detectCycle = (head) => {
  // 这里和 LeetCode 的双指针法有点不一样，因为这里需要严格的位置校验
  let fast = head
  let slow = head
  let pointer = head
  // 循环使快慢指针相遇
  for(;;) {
    if (fast === null || fast.next === null) {
       return null 
    }
    slow = slow.next
    fast = fast.next.next
    // 相遇时退出
    if (slow === fast) {
      break
    }
  }

  // 此时 slow 多走的距离刚好是成环前的距离，所以此时用一个头指针依次和 slow 依次向后走就会在环的入口相遇
  while (pointer !== slow) {
    pointer = pointer.next
    slow = slow.next
  }
  return slow
}
```

