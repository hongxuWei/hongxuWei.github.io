<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>前端工程化</title>
      <link href="/2019/08/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
      <url>/2019/08/15/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="前端历史"><a href="#前端历史" class="headerlink" title="前端历史"></a>前端历史</h2><p><img src="/2019/08/15/前端/前端工程化/history.png" alt="前端技术发展"></p><h2 id="一个面试常见的问题（从输入-URL-到页面加载发生了什么）"><a href="#一个面试常见的问题（从输入-URL-到页面加载发生了什么）" class="headerlink" title="一个面试常见的问题（从输入 URL 到页面加载发生了什么）"></a>一个面试常见的问题（从输入 URL 到页面加载发生了什么）</h2><div id="render" class="center" style="opacity: 1;" onclick="document.getElementById('render').style.opacity = 1"><img src="/2019/08/15/前端/前端工程化/render.png" alt="browser"></div><!--div id="js-runtime" class="center" style="opacity: 0;" onclick="document.getElementById('js-runtime').style.opacity = 1">![js-runtime](js-runtime.png)</div--><p class="center"><img src="/2019/08/15/前端/前端工程化/browser-render.png" alt="browser-render"></p><h2 id="关注的技术指标"><a href="#关注的技术指标" class="headerlink" title="关注的技术指标"></a>关注的技术指标</h2><p>天下武功，唯快不破。</p><p><img src="/2019/08/15/前端/前端工程化/time.png" alt="处理时间"></p><ul><li><p>首字节时间（用于衡量网络链路和服务器响应性能）</p></li><li><p>白屏时间（firstPaint）</p></li></ul><p>白屏时间 = 开始渲染时间(首字节时间+HTML下载完成时间) + 头部资源加载时间</p><p><code>(chrome.loadTimes().firstPaintTime - chrome.loadTimes().startLoadTime) * 1000</code></p><ul><li>可交互时间（interactive）</li></ul><p><code>performance.timing.domInteractive - performance.timing.navigationStart</code></p><ul><li>完全加载时间（load）</li></ul><p><code>performance.timing.loadEventStart- performance.timing.navigationStart</code></p><h2 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a>分析工具</h2><p><strong>Chrome Dev Tools</strong></p><p class="center"><img src="/2019/08/15/前端/前端工程化/chrome-dev-tools.png" alt="Chrome Dev Tools"></p><p><strong>Performance-Analyser</strong></p><p class="center"><img src="/2019/08/15/前端/前端工程化/performance-an.png" alt="Performance-Analyser"></p><p><strong>Lighthouse</strong></p><p class="center"><img src="/2019/08/15/前端/前端工程化/lighthouse.png" alt="Lighthouse"></p><h2 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h2><p><strong>网络层面</strong></p><ol><li>静态资源部署到 CDN (Content Delivery Network)</li><li>DNS Prefetch</li><li>合理设置缓存</li><li>减少 HTTP 请求</li><li>减少资源体积</li><li>减少页面重定向</li><li>域名切分</li></ol><p><strong>浏览器解析层面</strong></p><ol><li>合理的 HTML 结构</li><li>合理使用异步脚本加载和动态脚本加载</li><li>触发 GPU 渲染加速</li></ol><p><a href="https://hongxuwei.github.io/2019/06/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">前端性能优化</a></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li><a href="https://developers.google.com/speed/docs/insights/rules" target="_blank" rel="noopener">PageSpeed Insights 规则</a></li><li><a href="https://juejin.im/post/5b5ed5046fb9a04fd343a8c7" target="_blank" rel="noopener">前端性能指标统计</a></li></ol>]]></content>
      
      <categories>
          
          <category> 图片压缩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
            <tag> 工程化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>create-react-app 怎么这么 Diao!</title>
      <link href="/2019/08/02/%E5%89%8D%E7%AB%AF/Create-React-App-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88-diao/"/>
      <url>/2019/08/02/%E5%89%8D%E7%AB%AF/Create-React-App-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88-diao/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间自己做了一个前端脚手架工具 Zeus，通过 cli 命令去搭建前端框架，目前支持了 web, node 工具类，chrome 扩展插件等模板。<br>其实原理都是一样的，根据不同的配置去 down 不同的 template，以及执行相应的 script。在做的过程中发现模板的搭建还真不是一个容易的活，踩过了各种坑，但同时对 webpack, rollup 这些工具也有了深入的了解。所以就在想 <a href="https://facebook.github.io/create-react-app/" target="_blank" rel="noopener">create-react-app</a> 是如何实现类似功能的。</p><p>这个系列打算从 create-react-app 着手去分析它的源码。希望自己能够坚持下去~</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h4 id="一级目录结构"><a href="#一级目录结构" class="headerlink" title="一级目录结构"></a>一级目录结构</h4><p class="center"><img src="/2019/08/02/前端/Create-React-App-为什么这么-diao/tree_root.1.png" alt="一级目录结构"></p><p>create-react-app 使用 <a href="https://lerna.js.org/" target="_blank" rel="noopener">Lerna</a> 管理前端 packages</p><p>值得关注的代码在 packages 这个目录下面</p><p>我们来看看 packages 里面都有什么</p><h4 id="packages-目录结构"><a href="#packages-目录结构" class="headerlink" title="packages 目录结构"></a>packages 目录结构</h4><p class="center"><img src="/2019/08/02/前端/Create-React-App-为什么这么-diao/tree_root_packages.1.png" alt="packages 目录结构"></p><p>这里有我们熟悉的 create-react-app 目录，其余的包也挺重要，比如 react-scripts 但是我们先找到入口再来看其他文件夹的作用吧。</p><p>我们要找的入口就在 create-react-app 里面</p><h4 id="create-react-app-目录结构"><a href="#create-react-app-目录结构" class="headerlink" title="create-react-app 目录结构"></a>create-react-app 目录结构</h4><p class="center"><img src="/2019/08/02/前端/Create-React-App-为什么这么-diao/tree_root_packages_create_react_app.1.png" alt="create-react-app 目录结构"></p><h2 id="create-react-app-源码解读"><a href="#create-react-app-源码解读" class="headerlink" title="create-react-app 源码解读"></a>create-react-app 源码解读</h2><h3 id="create-react-app-用法"><a href="#create-react-app-用法" class="headerlink" title="create-react-app 用法"></a>create-react-app 用法</h3><p>在看源码之前，我们要先知道如何使用 creat-react-app 这样能够帮助我们快速理解各部分代码的作用。</p><p class="center"><img src="/2019/08/02/前端/Create-React-App-为什么这么-diao/how-to-use.png" alt="how to use"></p><p>可以看到用法就是 <code>create-react-app &lt;project-directory&gt; [options]</code></p><p>非常的简单易用，而且各参数的作用简单易懂，一看就知道怎么使用，命名非常的好。</p><h3 id="create-rect-app-index-js"><a href="#create-rect-app-index-js" class="headerlink" title="create-rect-app/index.js"></a>create-rect-app/index.js</h3><p>这是入口文件非常简明，就是判断当前 node 版本，如果主版本低于 8 就输出一段错误提示信息，并终止进程。并返回 1 作为退出码。<em>(Linux 系统中只有 0 是成功码，其余的退出码都表示进程没有按预期执行成功)</em><br>如果主版本适配，那么就执行 creatReactApp 里的代码</p><pre><code class="javascript">var currentNodeVersion = process.versions.node;var semver = currentNodeVersion.split(&#39;.&#39;);var major = semver[0];if (major &lt; 8) {  console.error(    &#39;You are running Node &#39; +      currentNodeVersion +      &#39;.\n&#39; +      &#39;Create React App requires Node 8 or higher. \n&#39; +      &#39;Please update your version of Node.&#39;  );  process.exit(1);}require(&#39;./createReactApp&#39;);</code></pre><h3 id="create-rect-app-createReactApp-js"><a href="#create-rect-app-createReactApp-js" class="headerlink" title="create-rect-app/createReactApp.js"></a>create-rect-app/createReactApp.js</h3><p>这里的代码就有点多了，不能把全部都给粘上来。我们一步步分析。</p><pre><code class="javascript">const chalk = require(&#39;chalk&#39;);const commander = require(&#39;commander&#39;);const dns = require(&#39;dns&#39;);const envinfo = require(&#39;envinfo&#39;);const execSync = require(&#39;child_process&#39;).execSync;const fs = require(&#39;fs-extra&#39;);const hyperquest = require(&#39;hyperquest&#39;);const inquirer = require(&#39;inquirer&#39;);const os = require(&#39;os&#39;);const path = require(&#39;path&#39;);const semver = require(&#39;semver&#39;);const spawn = require(&#39;cross-spawn&#39;);const tmp = require(&#39;tmp&#39;);const unpack = require(&#39;tar-pack&#39;).unpack;const url = require(&#39;url&#39;);const validateProjectName = require(&#39;validate-npm-package-name&#39;);const packageJson = require(&#39;./package.json&#39;);</code></pre><p>这里我们忽略头上的包的引用，直接看代码</p><p>使用 <a href="https://github.com/tj/commander.js" target="_blank" rel="noopener">commander</a> 做命令行工具</p><pre><code class="javascript">// 这段代码只是对该工具可以用哪些方法做一个声明和初始化let projectName;const program = new commander.Command(packageJson.name)  // 版本号  .version(packageJson.version)  .arguments(&#39;&lt;project-directory&gt;&#39;)  // 申明使用方法  .usage(`${chalk.green(&#39;&lt;project-directory&gt;&#39;)} [options]`)  .action(name =&gt; {    // 这里的 name 就是使用 create-react-app 传入的 &lt;project-directory&gt;    projectName = name;  })  // 申明 option 信息  .option(&#39;--verbose&#39;, &#39;print additional logs&#39;)  .option(&#39;--info&#39;, &#39;print environment debug info&#39;)  .option(    &#39;--scripts-version &lt;alternative-package&gt;&#39;,    &#39;use a non-standard version of react-scripts&#39;  )  .option(&#39;--use-npm&#39;)  .option(&#39;--use-pnp&#39;)  .option(&#39;--typescript&#39;)  .allowUnknownOption()  // 帮助信息  .on(&#39;--help&#39;, () =&gt; {/* 省略...  */})  .parse(process.argv);// 如果使用了 --info 参数就输出系统信息且不创建项目并返回if (program.info) {  console.log(chalk.bold(&#39;\nEnvironment Info:&#39;));  return envinfo    .run(      {        System: [&#39;OS&#39;, &#39;CPU&#39;],        Binaries: [&#39;Node&#39;, &#39;npm&#39;, &#39;Yarn&#39;],        Browsers: [&#39;Chrome&#39;, &#39;Edge&#39;, &#39;Internet Explorer&#39;, &#39;Firefox&#39;, &#39;Safari&#39;],        npmPackages: [&#39;react&#39;, &#39;react-dom&#39;, &#39;react-scripts&#39;],        npmGlobalPackages: [&#39;create-react-app&#39;],      },      {        duplicates: true,        showNotFound: true,      }    )    .then(console.log);}// 如果没哟输入项目名称就提示如何使用并退出(退出码为 1)if (typeof projectName === &#39;undefined&#39;) {  /* 省略... */  process.exit(1);}// 这申明了一个内部程序，当 --scripts-version 选项使用时才出发相应的操作// 可以下载自定义的模板文件const hiddenProgram = new commander.Command()  .option(    &#39;--internal-testing-template &lt;path-to-template&gt;&#39;,    &#39;(internal usage only, DO NOT RELY ON THIS) &#39; +      &#39;use a non-standard application template&#39;  )  .parse(process.argv);// 这里才是 creat-react-app 处理完输入参数后执行的函数，可以看到它吧相关参数信息都传到这个函数里的createApp(  projectName,  program.verbose,  program.scriptsVersion,  program.useNpm,  program.usePnp,  program.typescript,  hiddenProgram.internalTestingTemplate);</code></pre><p>那么下面我们看看 creatApp 这个函数里面做了什么吧</p><pre><code class="javascript">function createApp(  // 项目名称  name,  // 是否打印附加 log 信息  verbose,  // script 版本  version,  // 是否使用 npm  useNpm,  // 是否使用 Yarn Plug&#39;n&#39;Play  usePnp,  // 是否使用 ts  useTypescript,  // 模板  template) {  const root = path.resolve(name);  const appName = path.basename(root);  // 检测名称是否合法  checkAppName(appName);  // 具体实现 -&gt; node-fs-extra/lib/mkdirs/mkdirs-sync.js  // 总之就是如果该目录不存在就创建一个  fs.ensureDirSync(name);  // 判断该目录下是否已有一些冲突文件，如果有就认为覆盖现有文件有风险，就退出  if (!isSafeToCreateProjectIn(root, name)) {    process.exit(1);  }  console.log(`Creating a new React app in ${chalk.green(root)}.`);  console.log();  const packageJson = {    name: appName,    version: &#39;0.1.0&#39;,    private: true,  };  // 写入 package.json  fs.writeFileSync(    path.join(root, &#39;package.json&#39;),    JSON.stringify(packageJson, null, 2) + os.EOL  );  // useYarn 和 useNpm 不传的话就优先使用 yarn  const useYarn = useNpm ? false : shouldUseYarn();  const originalDirectory = process.cwd();  process.chdir(root);  // 如果不适用 yarn 且 npm 无法读取 cwd 就退出  if (!useYarn &amp;&amp; !checkThatNpmCanReadCwd()) {    process.exit(1);  }  // 判断当前 node 版本 如果低于 8.10.0 就使用 0.9.x 版本的 react-script  if (!semver.satisfies(process.version, &#39;&gt;=8.10.0&#39;)) {    console.log(      chalk.yellow(        `You are using Node ${          process.version        } so the project will be bootstrapped with an old unsupported version of tools.\n\n` +          `Please update to Node 8.10 or higher for a better, fully supported experience.\n`      )    );    // Fall back to latest supported react-scripts on Node 4    version = &#39;react-scripts@0.9.x&#39;;  }  if (!useYarn) {    const npmInfo = checkNpmVersion();    // 当前 npm 版本低于 5.0.0    if (!npmInfo.hasMinNpm) {      if (npmInfo.npmVersion) {        console.log(          chalk.yellow(            `You are using npm ${              npmInfo.npmVersion            } so the project will be bootstrapped with an old unsupported version of tools.\n\n` +              `Please update to npm 5 or higher for a better, fully supported experience.\n`          )        );      }      // Fall back to latest supported react-scripts for npm 3      version = &#39;react-scripts@0.9.x&#39;;    }  } else if (usePnp) {    const yarnInfo = checkYarnVersion();    // yarn 版本低于 1.12.0    if (!yarnInfo.hasMinYarnPnp) {      if (yarnInfo.yarnVersion) {        console.log(          chalk.yellow(            `You are using Yarn ${              yarnInfo.yarnVersion            } together with the --use-pnp flag, but Plug&#39;n&#39;Play is only supported starting from the 1.12 release.\n\n` +              `Please update to Yarn 1.12 or higher for a better, fully supported experience.\n`          )        );      }      // 1.11 had an issue with webpack-dev-middleware, so better not use PnP with it (never reached stable, but still)      usePnp = false;    }  }  if (useYarn) {    let yarnUsesDefaultRegistry = true;    try {      yarnUsesDefaultRegistry =        execSync(&#39;yarnpkg config get registry&#39;)          .toString()          .trim() === &#39;https://registry.yarnpkg.com&#39;;    } catch (e) {      // ignore    }    if (yarnUsesDefaultRegistry) {      fs.copySync(        require.resolve(&#39;./yarn.lock.cached&#39;),        path.join(root, &#39;yarn.lock&#39;)      );    }  }  // run ? 原来这才是真正处理操作的地方？  // createApp 只是处理一些 npm yarn 版本等操作？让我们接着看下去这个 run 是什么  run(    root,    appName,    version,    verbose,    originalDirectory,    template,    useYarn,    usePnp,    useTypescript  );}</code></pre><p>下面就是 run 函数啦</p><pre><code class="javascript">function run(  root,  appName,  version,  verbose,  originalDirectory,  template,  useYarn,  usePnp,  useTypescript) {  getInstallPackage(version, originalDirectory).then(packageToInstall =&gt; {    /* balabala 省略 */  });}</code></pre><p>啊，什么。run 里面就先执行了一个 <code>getInstallPackage</code> 函数，该函数 resolve 后再执行相应的内容。</p><p>那就继续 go! 先看看 <code>getInstallPackage</code> 再回头看看 balabala 里的内容吧</p><pre><code class="javascript">/* * 这里两个参数 version 表示的是 script 版本，可能是自带的 react-script 也可能是自定义的 git 地址等 * originalDirectory 表示的是 proces.cwd() 即当前命令执行的目录 */function getInstallPackage(version, originalDirectory) {  let packageToInstall = &#39;react-scripts&#39;;  // 处理要安装的包是哪一种  const validSemver = semver.valid(version);  if (validSemver) {    packageToInstall += `@${validSemver}`;  } else if (version) {    if (version[0] === &#39;@&#39; &amp;&amp; version.indexOf(&#39;/&#39;) === -1) {      packageToInstall += version;    } else if (version.match(/^file:/)) {      packageToInstall = `file:${path.resolve(        originalDirectory,        version.match(/^file:(.*)?$/)[1]      )}`;    } else {      // for tar.gz or alternative paths      packageToInstall = version;    }  }  const scriptsToWarn = [    {      name: &#39;react-scripts-ts&#39;,      message: chalk.yellow(        &#39;The react-scripts-ts package is deprecated. TypeScript is now supported natively in Create React App. You can use the --typescript option instead when generating your app to include TypeScript support. Would you like to continue using react-scripts-ts?&#39;      ),    },  ];  for (const script of scriptsToWarn) {    // 如果以 react-scripts-ts 开头的包就告诉用户 create-react-app 已经支持加 --typescript 参数就可以用    // 问是不是还要继续使用自定义的 react-scripts-ts 包如果反馈是是就继续下载，如果反馈是否程序正常结束退出不做任何工作。    if (packageToInstall.startsWith(script.name)) {      return inquirer        .prompt({          type: &#39;confirm&#39;,          name: &#39;useScript&#39;,          message: script.message,          default: false,        })        .then(answer =&gt; {          if (!answer.useScript) {            process.exit(0);          }          return packageToInstall;        });    }  }  // 这里把要安装的包给 resolve 出去  return Promise.resolve(packageToInstall);}</code></pre><p>ok, 看到这里大概知道了 getInstallPackage 这个函数就是根据参数将要下载的包名称返回而已。<br>那继续看看 run 函数 getInstallPackage 的 then 里面是什么操作吧。</p><pre><code class="javascript">function run(  root,  appName,  version,  verbose,  originalDirectory,  template,  useYarn,  usePnp,  useTypescript) {  getInstallPackage(version, originalDirectory).then(packageToInstall =&gt; {    // 这里包含所有的依赖项    const allDependencies = [&#39;react&#39;, &#39;react-dom&#39;, packageToInstall];    // 如果用了 ts 要额外装一些包    if (useTypescript) {      // 看到这里，哈哈哈哈，原来不管哪里的程序员都爱记 TODO      // 可以看到未来 create-react-app 会根据 node 和 jest 去安装对应的 types      allDependencies.push(        // TODO: get user&#39;s node version instead of installing latest        &#39;@types/node&#39;,        &#39;@types/react&#39;,        &#39;@types/react-dom&#39;,        // TODO: get version of Jest being used instead of installing latest        &#39;@types/jest&#39;,        &#39;typescript&#39;      );    }    console.log(&#39;Installing packages. This might take a couple of minutes.&#39;);    /*     * getPackageName 就是根据 packageToInstall 判断是那种类型的包     * tgz|tar.gz 的压缩包     * git 仓库     * @version or @tag 类型的     * file: 本地文件名类型的     */    getPackageName(packageToInstall)      .then(packageName =&gt;        // 检查是否在线        checkIfOnline(useYarn).then(isOnline =&gt; ({          isOnline: isOnline,          packageName: packageName,        }))      )      .then(info =&gt; {        const isOnline = info.isOnline;        const packageName = info.packageName;        console.log(          `Installing ${chalk.cyan(&#39;react&#39;)}, ${chalk.cyan(            &#39;react-dom&#39;          )}, and ${chalk.cyan(packageName)}...`        );        console.log();        // 开始安装对应的包        return install(          root,          useYarn,          usePnp,          allDependencies,          verbose,          isOnline        ).then(() =&gt; packageName);      })      .then(async packageName =&gt; {        // 检查当前 node 版本是否符合下载的包的 package.json 中要求的 node 版本        checkNodeVersion(packageName);        // 设置 react react-dom 版本为带 ^ 的版本号        setCaretRangeForRuntimeDeps(packageName);        const pnpPath = path.resolve(process.cwd(), &#39;.pnp.js&#39;);        const nodeArgs = fs.existsSync(pnpPath) ? [&#39;--require&#39;, pnpPath] : [];        // 执行下载好的文件内的 init 脚本        await executeNodeScript(          {            cwd: process.cwd(),            args: nodeArgs,          },          [root, appName, verbose, originalDirectory, template],          `        var init = require(&#39;${packageName}/scripts/init.js&#39;);        init.apply(null, JSON.parse(process.argv[1]));      `        );        if (version === &#39;react-scripts@0.9.x&#39;) {          console.log(            chalk.yellow(              `\nNote: the project was bootstrapped with an old unsupported version of tools.\n` +                `Please update to Node &gt;=8.10 and npm &gt;=5 to get supported tools in new projects.\n`            )          );        }      })      .catch(reason =&gt; {        console.log();        console.log(&#39;Aborting installation.&#39;);        if (reason.command) {          console.log(`  ${chalk.cyan(reason.command)} has failed.`);        } else {          console.log(            chalk.red(&#39;Unexpected error. Please report it as a bug:&#39;)          );          console.log(reason);        }        console.log();        // On &#39;exit&#39; we will delete these files from target directory.        // exit 前删除目标文件夹内的文件列表        const knownGeneratedFiles = [          &#39;package.json&#39;,          &#39;yarn.lock&#39;,          &#39;node_modules&#39;,        ];        const currentFiles = fs.readdirSync(path.join(root));        currentFiles.forEach(file =&gt; {          knownGeneratedFiles.forEach(fileToMatch =&gt; {            // This removes all knownGeneratedFiles.            if (file === fileToMatch) {              console.log(`Deleting generated file... ${chalk.cyan(file)}`);              fs.removeSync(path.join(root, file));            }          });        });        const remainingFiles = fs.readdirSync(path.join(root));        if (!remainingFiles.length) {          // Delete target folder if empty          console.log(            `Deleting ${chalk.cyan(`${appName}/`)} from ${chalk.cyan(              path.resolve(root, &#39;..&#39;)            )}`          );          process.chdir(path.resolve(root, &#39;..&#39;));          fs.removeSync(path.join(root));        }        console.log(&#39;Done.&#39;);        process.exit(1);      });  });}</code></pre><p>嗯，看到这里发现自己写的 Zeus 项目和 create-react-app 的思路是非常的像的。</p><p>creat-react-app 和 Zeus 都是分为两个部分，一个是命令部分，一个是模板 template 部分。然后通过命令去交互式询问并下载相应的 template。</p><p>只不过 Zeus 不支持自定义的模板，但优势就是比 creat-react-app 有更加友好的交互方式，遇到无法处理的情况会询问用户来选择如何处理。（比如目标目录已经存在 creat-react-app 会自动退出，而 Zeus 会询问用户是覆盖还是主动修改名称或者取消）这带给了用户更好的体验，还是会在未来写脚本的时候带来麻烦？这就看具体的使用场景了。至少目前使用 Zeus 下来还是不错的。</p><p>这个系列下一篇会分析 react-script 这个目录下的文件。这里面包含了模板文件，同时也让我们看看 create-react-app 是如何写 webpack 的吧。</p><p>这里是我不知道的知识点<br><strong>拓展 <a href="https://yarn.bootcss.com/docs/pnp/" target="_blank" rel="noopener">Yarn Plug’n’Play</a></strong></p>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React 前端工程 create-react-app </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链表2</title>
      <link href="/2019/07/31/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A82/"/>
      <url>/2019/07/31/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A82/</url>
      <content type="html"><![CDATA[<h2 id="环形链表-II-LeetCode-142"><a href="#环形链表-II-LeetCode-142" class="headerlink" title="环形链表 II LeetCode#142"></a>环形链表 II LeetCode#142</h2><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。<br>说明：不允许修改给定的链表。</p><pre><code>示例 1：输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="/2019/07/31/算法/链表2/LeetCode142Question1.png" alt="LeetCode142Question1"></p><pre><code>示例 2：输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="/2019/07/31/算法/链表2/LeetCode142Question2.png" alt="LeetCode142Question2"></p><pre><code>示例 3：输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。</code></pre><p><img src="/2019/07/31/算法/链表2/LeetCode142Question3.png" alt="LeetCode142Question3"><br>进阶：<br>你是否可以不用额外空间解决此题？</p></blockquote><h4 id="1-缓存法"><a href="#1-缓存法" class="headerlink" title="1. 缓存法"></a>1. 缓存法</h4><p>该解法与 LeetCode 141 的解法一样，用缓存把每个节点缓存起来，然后不断遍历链表并判断节点是否已经存在，如果已经存在就返回该节点。<br>这种方法的缺点也明显，时间复杂度高，空间复杂度也高</p><pre><code class="javascript">// arrary memoryconst hasCycle = (head) =&gt; {  if(head === null) {    return false  }  const memory = []  while (head !== null) {    if (memory.indexOf(head) &gt; -1) {      return true    }    memory.push(head)    head = head.next  }  return false}// set memoryconst detectCycle = (head) =&gt; {  if(head === null) {    return head  }  // 用 set 模拟 hash table  const memory = new Set()  while (head !== null) {    if (memory.has(head)) {      return head    }    memory.add(head)    head = head.next  }  return head}</code></pre><h4 id="2-Floyd-算法"><a href="#2-Floyd-算法" class="headerlink" title="2. Floyd 算法"></a>2. Floyd 算法</h4><p>该解法是在 LeetCode 141 双指针法的基础上变化而来的。如果不看答案，我是想不出这种纯数学的解法的。</p><p>分为两个阶段</p><ul><li>判断是否有环</li><li>找出环入口（这里是一个比较巧妙的数学解法）</li></ul><p>具体证明 -&gt; <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode 142 Floyd 算法</a></p><pre><code class="javascript">const detectCycle = (head) =&gt; {  // 这里和 LeetCode 的双指针法有点不一样，因为这里需要严格的位置校验  let fast = head  let slow = head  let pointer = head  // 循环使快慢指针相遇  for(;;) {    if (fast === null || fast.next === null) {       return null     }    slow = slow.next    fast = fast.next.next    // 相遇时退出    if (slow === fast) {      break    }  }  // 此时 slow 多走的距离刚好是成环前的距离，所以此时用一个头指针依次和 slow 依次向后走就会在环的入口相遇  while (pointer !== slow) {    pointer = pointer.next    slow = slow.next  }  return slow}</code></pre><h2 id="重排链表-LeetCode-143"><a href="#重排链表-LeetCode-143" class="headerlink" title="重排链表 LeetCode#143"></a>重排链表 LeetCode#143</h2><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><pre><code>示例 1:给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.示例 2:给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</code></pre></blockquote><h4 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h4><p>思路：首先遍历一遍链表并把每个节点按顺序存放起来，第二遍按照要求从数组中取值并拼接起来链表</p><p>时间复杂度 O(n) 空间复杂度O(n)</p><pre><code class="javascript">const reorderList = (head) =&gt; {  if (head === null) {    return head  }  const memory = []  let pointer = head  // 遍历并存放节点信息  while (pointer !== null) {    memory.push(pointer)    pointer = pointer.next  }  const pRes = new ListNode()  pointer = pRes   const len = memory.length  // 按要求不断拼接 list  while(memory.length &gt; 0) {    pointer.next = memory.shift()    pointer = pointer.next    if (memory.length &gt; 0) {      pointer.next = memory.pop()      pointer = pointer.next    }  }  // 注意处理最后一个节点的 next 引用值，否则会溢出  pointer.next = null  return pRes.next}</code></pre><h4 id="2-反转合并法"><a href="#2-反转合并法" class="headerlink" title="2. 反转合并法"></a>2. 反转合并法</h4><p>思路：</p><ol><li>用快慢指针找到链表中点</li><li>反转中点到链尾的链</li><li>合并中点前的链和中点后的链</li></ol><p>时间复杂度 O(n) 空间复杂度O(1)</p><pre><code class="javascript">const reorderList = (head) =&gt; {  if (head === null) {    return head  }  // fast 走两步，slow 走一步，fast 走完全链时 slow 的位置就是中点  let fast = head  let slow = head  while (fast !== null &amp;&amp; fast.next !== null) {    slow = slow.next    fast = fast.next.next  }  // 反转中点到链尾  const revertedList = revert(slow.next)  // 分割链表  slow.next = null  // 合并链表  let p1 = head  let p2 = revertedList  const pRes = new ListNode()  let pointer = pRes  while (p2 !== null) {    pointer.next = p1    pointer = pointer.next    p1 = p1.next    pointer.next = p2    pointer = pointer.next    p2 = p2.next  }  // 因为 p1 的长度总是和 p2 相等或者比 p2 大 1 个  // 所以这里要对 p1.length &gt; p2.length 做处理  if (p1) {    pointer.next = p1  }  return pRes.next}const revert = (head) =&gt; {  if (head === null) {    return null  }  const pRes = new ListNode()  let pointer = head  while (pointer !== null) {    const next = pointer.next    const resNext = pRes.next    // 反转链表    // 挂载头节点    pRes.next = pointer    // 挂载当前节点    pointer.next = resNext    // 移动节点    pointer = next  }  return pRes.next}</code></pre><h2 id="对链表进行插入排序-LeetCode-147"><a href="#对链表进行插入排序-LeetCode-147" class="headerlink" title="对链表进行插入排序 LeetCode#147"></a>对链表进行插入排序 LeetCode#147</h2><p class="center"><img src="/2019/07/31/算法/链表2/LeetCode147Question.gif" alt="LeetCode147Question"></p><blockquote><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。<br>插入排序算法：</p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。<pre><code>示例 1：输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><pre><code>示例 2：输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre></li></ol></blockquote><p>题目已经限制了解法。如下 ↓</p><pre><code class="javascript">const insertionSortList = (head) =&gt; {  // 特殊处理  if(head === null || head.next === null) {    return head  }  // 构造辅助链表  const first = new ListNode(0)  first.next = head  // 初始化  let currentNode = head  let prevNode = null  // 遍历链表  while(currentNode !== null) {    // 不是有序数据    if (currentNode.next &amp;&amp; currentNode.next.val &lt; currentNode.val) {      // 找到插入位置      prevNode = first      while (currentNode.next &amp;&amp; prevNode.next &amp;&amp; currentNode.next.val &gt; prevNode.next.val) {        prevNode = prevNode.next      }      // 缓存后续节点      let temp = currentNode.next      // 插入节点      currentNode.next = temp.next;      temp.next = prevNode.next;      prevNode.next = temp    } else {      // 顺序合理 或 是最后一个节点      currentNode = currentNode.next    }  }  return first.next}</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链表</title>
      <link href="/2019/07/14/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/07/14/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><blockquote><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。<br>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。</p></blockquote><p class="center"><img src="/2019/07/14/算法/链表/define.png" alt="定义"></p><br><p class="center">定义</p><h1 id="LeetCode-练习题"><a href="#LeetCode-练习题" class="headerlink" title="LeetCode 练习题"></a>LeetCode 练习题</h1><h2 id="两数相加-LeetCode-2"><a href="#两数相加-LeetCode-2" class="headerlink" title="两数相加 LeetCode#2"></a>两数相加 LeetCode#2</h2><blockquote><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br>示例：</p><pre><code>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre></blockquote><h4 id="1-先求解再转为链表"><a href="#1-先求解再转为链表" class="headerlink" title="1. 先求解再转为链表"></a><del>1. 先求解再转为链表</del></h4><ul><li>遍历两链表求出两数</li><li>两数相加求和</li><li>数字再转为链表</li></ul><p>这是相对来说比较直观的一种解法，关键就在链表转数字以及数字转链表</p><p>空间复杂度和时间复杂度都不是很理想</p><pre><code class="javascript">const ListNode = (val) =&gt; {  this.val = val  this.next = null}const number2List = (num) =&gt; {  const numArr = String(num).split(&#39;&#39;).map(item =&gt; Number(item))  const head = new ListNode()  let curNode = head  const len = numArr.length  for (let i = len; i &gt; 0; i--) {    curNode.val = numArr[i - 1]    curNode.next = i === 1 ? null : new ListNode()    curNode = curNode.next  }  return head}const list2Number = (list) =&gt; {  let weight = 0  let num = 0  while(list !== null) {    const curNum = list.val * Math.pow(10, weight)    num += curNum    weight += 1    list = list.next   }  return num}const addTwoNumbers = (l1, l2) =&gt; {  if (l1 === null) {    return l2  }  if (l2 === null) {    return l1  }  const number1 = list2Number(l1)  const number2 = list2Number(l2)  const sum = number1 + number2  return number2List(sum)}</code></pre><p>但是出错啦 TAT</p><p class="center"><img src="/2019/07/14/算法/链表/LeetCode2Error.png" alt="LeetCode2Error"></p><p>这就是没有考虑到超大数字。<br>不仅如此，如果最后的结果是 <code>Infinity</code> 这个方法就不起作用了。</p><h4 id="2-遍历两链表，用变量表示是否进位"><a href="#2-遍历两链表，用变量表示是否进位" class="headerlink" title="2. 遍历两链表，用变量表示是否进位"></a>2. 遍历两链表，用变量表示是否进位</h4><ul><li>两链表对应位置值相加</li><li>标志位有进位设为 1 无进位就设为 0（仅限两链表相加）</li></ul><p>时间复杂度是 O(n) 空间复杂度是 O(n)</p><p><strong>这里需要注意几种情况</strong></p><ol><li>链表位数不相同</li><li>最终结果值大于两链表最大位数</li></ol><pre><code class="javascript">const addTwoNumbers = (l1, l2) =&gt; {  if (l1 === null) {      return l2  }  if (l2 === null) {      return l1  }  const head = new ListNode(0)  let list1 = l1  let list2 = l2  let curNode = head  let carry = 0  while (list1 !== null || list2 !== null) {    const num1 = list1 === null ? 0 : list1.val    const num2 = list2 === null ? 0 : list2.val    // 这里注意不要忘记加进位的数    const sum = num1 + num2 + carry    // 处理进位    carry = sum &gt;= 10 ? 1 : 0    curNode.next = new ListNode(sum % 10)    curNode = curNode.next    // list 长度不一致的时候的特殊处理    if (list1 !== null) {      list1 = list1.next    }    if (list2 !== null) {      list2 = list2.next    }  }  // 遍历完后还有数字的特殊处理  if (carry !== 0) {    curNode.next = new ListNode(carry)  }  // 这里注意要返回 head 的 next 应为刚开始我们构造了一个无效的 Node 来辅助我们解题  return head.next}</code></pre><h2 id="删除链表的倒数第N个节点-LeetCode-19"><a href="#删除链表的倒数第N个节点-LeetCode-19" class="headerlink" title="删除链表的倒数第N个节点 LeetCode#19"></a>删除链表的倒数第N个节点 LeetCode#19</h2><blockquote><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br>示例：</p><pre><code>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</code></pre><p>说明：<br>给定的 n 保证是有效的。<br>进阶：<br>你能尝试使用一趟扫描实现吗？</p></blockquote><p>总之就是有一个 ListNode<br><strong>需要将 LN(n - 1) 的 next 指针 指向 LN(n + 1)</strong> 即<br><strong>LN(n - 1).next = LN(n + 1)</strong> 即<br><strong>LN(n - 1).next = LN(n - 1).next.next</strong></p><h4 id="1-数组存放链表信息"><a href="#1-数组存放链表信息" class="headerlink" title="1. 数组存放链表信息"></a>1. 数组存放链表信息</h4><p>我首先想到的是这么解</p><ul><li>遍历一遍链表并挨个放到数组里面</li><li>对应修改 n - 1 的 next 节点到 n + 1</li></ul><p><strong>这里要注意</strong></p><ol><li>n - 1 和 n + 1 是否存在</li></ol><p>这么解时间复杂度是 O(n) 但是由于引入一个数组所以是 O(n) 的空间复杂度</p><pre><code class="javascript">const removeNthFromEnd = (head, n) =&gt; {  if (head === null) {    return head  }  // 遍历一遍并存放链表数据  const memory = []  while (head !== null) {    memory.push(head)    head = head.next  }  // 当只有一个节点的特殊处理  const len = memory.length  if (len === 1) {    return memory[0].next  }  const index = len - n  // 当 n = 0 的特殊情况，此时不删除任何节点（因为题目说保证 n 有效，所以先注释掉）  // if (index === len) {  //   return memory[0]  // }  // 当 n = 链表总长度的特殊情况，此时无 n - 1  if (index === 0) {    return memory[1]  }  // 注意这里的 memory[index + 1] || null 是为了处理 n + 1 不存在的情况  memory[index - 1].next = memory[index + 1] || null  return memory[0]}</code></pre><p>但是有没有更好的解法</p><h4 id="2-双指针法"><a href="#2-双指针法" class="headerlink" title="2. 双指针法"></a>2. 双指针法</h4><p>这是 LeetCode 中文官方的一个解<br>思路就是有两个指针，第一个在前是 forwardP 另一个滞后与他 n + 1 个 Node<br>这样当第一个指针跑到最后时，第二个指针刚好就在倒数第 n - 1 个位置</p><p>这样就优化了之前存放临时数据的数组的空间</p><p>时间复杂度是 O(n) 空间复杂度是 O(1)</p><ul><li>两个指针初始位置都在头节点</li><li>指针 1 先向前走 n 个节点</li><li>两指针同时前进，当指针 1 跑到链表尾时更改指针 2 指向</li></ul><p class="center"><img src="/2019/07/14/算法/链表/LeetCode12Solution2.png" alt="LeetCode12Solution2"></p><pre><code class="javascript">const removeNthFromEnd = (head, n) =&gt; {  // 引入一个 head node 可以避免下面的很多判断  const _head = new ListNode()  _head.next = head  let forwardPointer = _head;  let pointer = _head;  // 指针 1 前进 n + 1步  for (let step = 1; step &lt;= n + 1; step++) {    forwardPointer = forwardPointer.next  }  // 双指针同时前进  while (forwardPointer !== null) {    forwardPointer = forwardPointer.next    pointer = pointer.next  }  // 删除第 n 个位置的值  pointer.next = pointer.next.next  return _head.next}</code></pre><h2 id="合并两个有序链表-LeetCode-21"><a href="#合并两个有序链表-LeetCode-21" class="headerlink" title="合并两个有序链表 LeetCode#21"></a>合并两个有序链表 LeetCode#21</h2><blockquote><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br>示例：</p><pre><code>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre></blockquote><h4 id="1-遍历两链表"><a href="#1-遍历两链表" class="headerlink" title="1. 遍历两链表"></a>1. 遍历两链表</h4><p>首先想到的是如下思路<br>思路：增加一个主链表，依次比较两链表的将小的节点加入主链表，最后将主链表返回</p><p>时间复杂度是 O(m + n) 空间复杂度是 O(1)</p><ul><li>比较两链表的当前节点</li><li>将值小的节点加入主链表</li><li>当有一个节点遍历到最后时将另一个链表的当前节点加入主链表</li></ul><pre><code class="javascript">const mergeTwoLists = (l1, l2) =&gt; {  // l1 l2 为空的特殊处理  if (l1 === null) {      return l2  }  if (l2 === null) {      return l1  }  const _head = new ListNode();  let pointer = _head  // 注意这里的遍历条件当有一个已经遍历完了之后就停止  while (l1 !== null &amp;&amp; l2 !== null) {    const l1IsMin = l1.val &lt; l2.val    pointer.next = l1IsMin ? l1 : l2    if (l1IsMin) {      l1 = l1.next    } else {      l2 = l2.next    }    pointer = pointer.next  }  pointer.next = l1 === null ? l2 : l1  return _head.next}</code></pre><h4 id="2-递归法-LeetCode-解法1"><a href="#2-递归法-LeetCode-解法1" class="headerlink" title="2. 递归法 - LeetCode 解法1"></a>2. 递归法 - LeetCode 解法1</h4><p>递归法只需要关注边界条件已经处理单节点逻辑，这样的话代码结构会比较清晰</p><p><strong>注意终止条件是 node === null</strong></p><p>时间复杂度是 O(m + n) 空间复杂度是 O(m + n)</p><pre><code class="javascript">const mergeTwoLists = (l1, l2) =&gt; {  // l1 l2 为空的特殊处理  if (l1 === null) {      return l2  }  if (l2 === null) {      return l1  }  // 选择值小的节点返回并处理 next 指向为递归结果  if (l1.val &lt; l2.val) {    l1.next = mergeTwoLists(l1.next, l2)    return l1  }  l2.next = mergeTwoLists(l1, l2.next)  return l2}</code></pre><h2 id="合并K个排序链表-LeetCode-23"><a href="#合并K个排序链表-LeetCode-23" class="headerlink" title="合并K个排序链表 LeetCode#23"></a>合并K个排序链表 LeetCode#23</h2><p>这题是 <a href="#合并两个有序链表-LeetCode-21">合并两个有序链表</a>的变种，我首先想到的方法与 #21-1 是同样的解法，只不过由比较两个数的大小改为比较 K 个数的大小。</p><h4 id="1-遍历-K-个链表"><a href="#1-遍历-K-个链表" class="headerlink" title="1. 遍历 K 个链表"></a>1. 遍历 K 个链表</h4><p>这种解法的时间复杂度是 O(k * n)，空间复杂度是 O(n)</p><pre><code class="javascript">const findMinIndex = (lists) =&gt; {  const len = lists.length  let min = null  let minIndex = -1  for (let i = 0; i &lt; len; i++) {    if (lists[i] === null) {      continue    }    if (min === null) {      min = lists[i].val      minIndex = i      continue    }    const curVal = lists[i].val    if (curVal &lt; min) {      minIndex = i      min = curVal    }  }  return minIndex}var mergeKLists = function(lists) {  let listLen = lists.length  // 处理特殊情况  if (listLen === 0) {    return null  }  const head = new ListNode()  let pointer = head  while (listLen &gt; 0) {    minIndex = findMinIndex(lists)    if (minIndex &lt; 0) {      return head.next    }    pointer.next = lists[minIndex]    pointer = pointer.next    lists[minIndex] = lists[minIndex].next  }  return head.next}</code></pre><h4 id="2-分治思想"><a href="#2-分治思想" class="headerlink" title="2. 分治思想"></a>2. 分治思想</h4><p>这是 LeetCode 官方解答之一</p><p class="center"><img src="/2019/07/14/算法/链表/LeetCode23Solution2.png" alt="LeetCode23Solution2"></p><pre><code class="javascript">const mergeKLists = (lists) =&gt; {  const len =  lists.length    let interval = 1    while (interval &lt; len) {      for(let i = 0; i &lt; len - interval; i = i + interval * 2) {        lists[i] = mergeTwoLists(lists[i], lists[i + interval])      }      interval = interval * 2    }    return len &gt; 0 ? lists[0] : null}</code></pre><h2 id="两两交换链表中的节点-LeetCode-24"><a href="#两两交换链表中的节点-LeetCode-24" class="headerlink" title="两两交换链表中的节点 LeetCode#24"></a>两两交换链表中的节点 LeetCode#24</h2><blockquote><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。<br>示例:</p><pre><code>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre></blockquote><h4 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1. 遍历"></a>1. 遍历</h4><p><strong>每次循环的 step 相当于等于 2</strong><br><strong>注意终止条件有两个<code>一个是当前节点为 null</code> 另一个是 <code>next 节点为 null</code></strong></p><p>该方法时间复杂度是 O(n)，由于创建新的链表顾空间复杂度也为 O(n)</p><pre><code class="javascript">const swapPairs = (head) =&gt; {  if (head === null) {    return head  }  const _head = new ListNode()  // 指向返回链表的当前节点  let cursor = _head  // 指向原始链表的当前节点  let pointer = head  while (pointer !== null) {    if (pointer.next === null) {      cursor.next = new ListNode(pointer.val)      cursor = cursor.next      break    }    // 交换链表节点值    cursor.next = new ListNode(pointer.next.val)    cursor.next.next = new ListNode(pointer.val)    // 循环步长为 2    cursor = cursor.next.next    pointer = pointer.next.next  }  // 注意处理尾节点的 next 为 null  cursor.next = null  return _head.next}</code></pre><h4 id="2-递归法"><a href="#2-递归法" class="headerlink" title="2. 递归法"></a>2. 递归法</h4><pre><code class="javascript">const swapPairs = (head) =&gt; {  // 特殊处理  if (head === null || head.next === null) {    return head  }  const next = head.next  head.next = swapPairs(next.next)  next.next = head  return next}</code></pre><h2 id="K-个一组翻转链表-LeetCode-25"><a href="#K-个一组翻转链表-LeetCode-25" class="headerlink" title="K 个一组翻转链表 LeetCode#25"></a>K 个一组翻转链表 LeetCode#25</h2><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。<br>示例:</p><pre><code>给定这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</code></pre><p>说明:<br>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p></blockquote><p>这题我的想法是两个指针 一个指向每次要翻转的最后一个节点记为 lastNode，另一个指针从当前要反转的起始位置开始一直走到最后一个节点 记为 curNode，每次走的时候 lastNode -&gt; curNode，来实现翻转的目的。<br>但是提交的时候各种边界条件没有考虑清楚，提交了很多次都没 ac。</p><h4 id="1-遍历-1"><a href="#1-遍历-1" class="headerlink" title="1. 遍历"></a>1. 遍历</h4><p>好吧这题太难了，下次再做 😝<br>国际惯例记一个 <em>TODO</em></p><h2 id="旋转链表-LeetCode-61"><a href="#旋转链表-LeetCode-61" class="headerlink" title="旋转链表 LeetCode#61"></a>旋转链表 LeetCode#61</h2><blockquote><p>给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。<br>示例 1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code></pre><p>示例 2:</p><pre><code>输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre></blockquote><h4 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h4><p>这是我最先想到的解法，把node 信息放到一个数组里<br>更具 k 依次遍历对应 Node 进行旋转</p><p>时间复杂度 O(n + k) 空间复杂度 O(n)</p><pre><code class="javascript">// 根据右旋值 i 计算应当移动的节点在数组的哪个位置const calcIndex = (len, i) =&gt; {  if(len &gt; i) {    return len - i  }  const rest = i % len  let index = 0  if (rest) {    index = len - rest  }  return index}const rotateRight = (head, k) =&gt; {  // 特殊情况  if (k === 0) {    return head  }  const allLinks = []  let pointer = head  // 获取链表的所有信息  while (pointer !== null) {    allLinks.push(pointer)    pointer = pointer.next  }  const linksLen = allLinks.length  // 无链表数据及只有 1 个链表数据  if (linksLen === 0 || linksLen === 1) {    return head  }  // 无效右旋过滤  k = k % linksLen  let _head = head  // 开始右旋  for (let i = 1; i &lt;= k; i++) {    const index = calcIndex(linksLen, i)    const prevNodexIndex = calcIndex(linksLen, i + 1)    const curNode = allLinks[index]    const prevNode = allLinks[prevNodexIndex]    curNode.next = _head    prevNode.next = null    _head = curNode  }  return _head}</code></pre><h4 id="2-形成环链表法"><a href="#2-形成环链表法" class="headerlink" title="2. 形成环链表法"></a>2. 形成环链表法</h4><p>这种解法也是 LeetCode 官方解法之一。<br>其思路就是将链表构成一个环，再在对应的地方切断。就自然而然的形成了右移</p><p>时间复杂度 O(2n - k) 空间复杂度 O(1)</p><pre><code class="javascript">const rotateRight = (head, k) =&gt; {  // 特殊情况处理  if(head === null || head.next === null || k === 0) {    return head  }  // 留住头结点翻遍成环  const _head = head  let linkLen = 1;  // 先找到尾节点，并得出链表长度用于后续计算 拆开节点位置  while (head.next !== null) {    head = head.next    linkLen += 1  }  // 形成闭环  head.next = _head  // 计算在何处拆开节点  // 这一步决定了结果是否正确非常重要  // 这里计算要移动的位置是返回值的表尾，表尾 next 就是返回值的 表头  const breakKey = linkLen &lt; k ? linkLen - (k % linkLen) : linkLen - k  // 移动到该节点  for (let i = 1; i &lt;= breakKey; i++) {    head = head.next  }  // 拆开环链表  const rHead = head.next  head.next = null  return rHead}</code></pre><h2 id="删除排序链表中的重复元素-II-LeetCode-82"><a href="#删除排序链表中的重复元素-II-LeetCode-82" class="headerlink" title="删除排序链表中的重复元素 II LeetCode#82"></a>删除排序链表中的重复元素 II LeetCode#82</h2><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。<br>示例 1:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5</code></pre><p>示例 2:</p><pre><code>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3</code></pre></blockquote><p>因为是有序链表，所以依次遍历，比较当前节点与上一个节点和下一个节点是否一致如果有重复就不返回</p><p>时间复杂度 O(n) 空间复杂度 O(1)</p><pre><code class="javascript">const deleteDuplicates = (head) =&gt; {  const result = new ListNode()  let point = result  let cur = head  let prev = new ListNode(null)  while (cur !== null) {    /* 两种情况可认为该节点有效      1. 前继节点值和当前节点值不一样 且 后继几点为 null      2. 前继节点值和当前节点值不一样 且 当前节点值和后继节点值不一样 */    if (( prev.val !== cur.val &amp;&amp; cur.next === null)      || (prev.val !== cur.val &amp;&amp; cur.val !== cur.next.val)    ) {      // 将当前节点加入      point.next = cur      point = point.next    }    prev = cur    cur = cur.next  }  // ！！注意这里要 尾节点 next 置为 null  point.next = null  return result.next}</code></pre><h2 id="删除排序链表中的重复元素-LeetCode-83"><a href="#删除排序链表中的重复元素-LeetCode-83" class="headerlink" title="删除排序链表中的重复元素 LeetCode#83"></a>删除排序链表中的重复元素 LeetCode#83</h2><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。<br>示例 1:</p><pre><code>输入: 1-&gt;1-&gt;2输出: 1-&gt;2</code></pre><p>示例 2:</p><pre><code>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3</code></pre></blockquote><p>这题和 #82 很像思路也差不多<br>因为是有序的，直接比较当前值和下一个值是否一样<br>如果一样就把当前节点 next 转为其孙子节点 这样就实现了删除重复节点</p><p>时间复杂度 O(n) 空间复杂度 O(1)</p><pre><code class="javascript">const deleteDuplicates = (head) =&gt; {  let _head = head  while(_head) {    // 下一个节点和当前节点重复    if(_head.next &amp;&amp; _head.val === _head.next.val) {      // 删除下一个重复节点      _head.next = _head.next.next      // 不移动 _head 指针，下一个值继续与当前循环 _head 比较      continue    }    _head = _head.next  }  return head}</code></pre><h2 id="分隔链表-LeetCode-86"><a href="#分隔链表-LeetCode-86" class="headerlink" title="分隔链表 LeetCode#86"></a>分隔链表 LeetCode#86</h2><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。<br>你应当保留两个分区中每个节点的初始相对位置。<br>示例:</p><pre><code>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></pre></blockquote><p>思路：<br>两个指针一个叫 prev 一个叫 next，遍历链表的同时分别将值对应到 prev 和 next 里面<br>最终结束的时候再讲 prev 和 next 拼接起来并返回</p><p>时间复杂度 O(n) 空间复杂度 O(1)</p><pre><code class="javascript">const partition = (head, x) =&gt; {  // 特殊处理  if (head === null || head.next === null) {    return head  }  // 建两个指针 prev 放 &lt; x 的节点  let prev = new ListNode()  const prevHead = prev  // next 放 &gt;= x 的 节点  let next = new ListNode()  const nextHead = next  // 遍历节点  while (head !== null) {    // 判断并放入节点到对应链表    if (head.val &lt; x) {      prev.next = head      prev = prev.next    } else {      next.next = head      next = next.next    }    head = head.next  }  // ！！处理尾节点 next 值  next.next = null  // 合并  prev.next = nextHead  return prevHead};</code></pre><h2 id="反转链表-II-LeetCode-92"><a href="#反转链表-II-LeetCode-92" class="headerlink" title="反转链表 II LeetCode#92"></a>反转链表 II LeetCode#92</h2><blockquote><p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。<br>说明:<br>1 ≤ m ≤ n ≤ 链表长度。<br>示例:</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre></blockquote><h4 id="1-拼接法"><a href="#1-拼接法" class="headerlink" title="1. 拼接法"></a>1. 拼接法</h4><p>依次遍历，并记录关键节点和链表</p><p>x &lt; m 时记录 prev<br>x = m 时记录 mNode<br>当 m &lt; x &lt;= n 时将当前节点插入 mNode 之前<br>x = n 时记录 nNode<br>记录 nNode.next 为 next</p><p>那最终结果就是 prev -&gt; nNode ~ mNode -&gt; next 且 nNode ~ mNode 已经反转好了</p><p>时间复杂度是 O(n) 空间复杂度是 O(1)</p><pre><code class="javascript">const reverseBetween = (head, m, n) =&gt; {  if (m === n || head === null) {    return head  }  const _head = new ListNode()  let currentKey = 1  // 第 m 个节点前面的所有节点  let prev = _head  // 第 m 个节点  let mNode = null  // 第 n 个节点  let nNode = null  // 第 n 个几点的后一个节点  let next = null  // 当前节点  let curNode = head  // 反向插入的几点  let point = null // 最终结果 可以近似为 // prev -&gt; nNode -&gt; n - m - 1 个 point 翻转而成的节点 -&gt; mNode -&gt; next  while (curNode !== null) {    const cNext = curNode.next    // 保存 prev 链    if (currentKey &lt; m) {      prev.next = curNode      prev = prev.next    }    // 保存 m 节点，初始化 point 节点    if (currentKey === m) {      mNode = curNode      point = mNode    }    // 保存 n 节点，next 节点    if (currentKey === n) {      nNode = curNode      next = cNext    }    // 反转节点    if(currentKey &gt; m &amp;&amp; currentKey &lt;= n) {      curNode.next = point      point = curNode    }    curNode = cNext    currentKey++  }  // 拼接合并节点  prev.next = nNode  mNode.next = next  return _head.next}</code></pre><h4 id="2-gt-LeetCode-官方解答"><a href="#2-gt-LeetCode-官方解答" class="headerlink" title="2. -&gt; LeetCode 官方解答"></a>2. -&gt; <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode 官方解答</a></h4><h2 id="环形链表-LeetCode-141"><a href="#环形链表-LeetCode-141" class="headerlink" title="环形链表 LeetCode#141"></a>环形链表 LeetCode#141</h2><blockquote><p>给定一个链表，判断链表中是否有环。<br>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><pre><code>示例 1：输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><p><img src="/2019/07/14/算法/链表/LeetCode141Question1.png" alt="LeetCode141Question1"></p><pre><code>示例 2：输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><p><img src="/2019/07/14/算法/链表/LeetCode141Question2.png" alt="LeetCode141Question2"></p><pre><code>示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><p><img src="/2019/07/14/算法/链表/LeetCode141Question3.png" alt="LeetCode141Question3"><br>进阶：<br>你能用 O(1)（即，常量）内存解决此问题吗？</p></blockquote><h4 id="1-缓存法"><a href="#1-缓存法" class="headerlink" title="1. 缓存法"></a>1. 缓存法</h4><p>我的解法是用一个数组保存每个节点，然后判断 Node 是否存在于数组中，如果存在了即为有环形<br>但是这种算法的时间复杂度是 O(n ^ n) 空间复杂度是 O(n)</p><p>如果可以用 hash 表开存储就可以将时间复杂变为 O(n)</p><pre><code class="javascript">// arrary memoryconst hasCycle = (head) =&gt; {  if(head === null) {    return false  }  const memory = []  while (head !== null) {    if (memory.indexOf(head) &gt; -1) {      return true    }    memory.push(head)    head = head.next  }  return false}// hash memoryconst hasCycle = (head) =&gt; {  if(head === null) {    return false  }  // set 模拟 hash table  const memory = new Set()  while (head !== null) {    if (memory.has(head)) {      return true    }    memory.add(head)    head = head.next  }  return false}</code></pre><h4 id="2-双指针法-1"><a href="#2-双指针法-1" class="headerlink" title="2. 双指针法"></a>2. 双指针法</h4><p>LeetCode 解法之二，这种解法没有想到。这里就说下 LeetCode 官方的解释。</p><p>通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)。慢指针每次移动一步，而快指针每次移动两步。</p><p>如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。</p><p>现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。</p><pre><code class="javascript">const hasCycle = (head) =&gt; {  if (head === null || head.next === null) {    return false  }  let slow = head  let fast = head.next  while (slow !== fast) {    // 快指针结束表示无环    if (fast === null || fast.next === null) {      return false    }    // 慢指针走一步    slow = slow.next    // 快指针走两步    fast = fast.next.next  }  // 慢指针和快指针相遇  return true}</code></pre>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端性能优化</title>
      <link href="/2019/06/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/06/17/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><blockquote><p>【前言】<br>之前面试一直被问到一个问题就是前端有哪些性能优化的点，但是每次回答自己都觉得不满意 ( 1. 回答不完整，有所遗漏 2. 回答没条理，想到哪就说到哪 )<br>故开此一篇梳理一下。</p></blockquote><p>具体优化方向可以根据浏览器 <code>performance</code> api 结合 Chrome DevelopTool Performance 面板进行分析</p><p>这里就介绍一些通用的优化技巧</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>减少不必要的网络请求造成的延迟，等待等问题</p><h5 id="1-静态资源部署到-CDN-Content-Delivery-Network"><a href="#1-静态资源部署到-CDN-Content-Delivery-Network" class="headerlink" title="1. 静态资源部署到 CDN (Content Delivery Network)"></a>1. 静态资源部署到 CDN (Content Delivery Network)</h5><h5 id="2-DNS-Prefetch"><a href="#2-DNS-Prefetch" class="headerlink" title="2. DNS Prefetch"></a>2. DNS Prefetch</h5><p>由于浏览器对单个域名的最大并发连接数有一定的限制（HTTP/1.0 和 HTTP/1.1）所以有的网站会对资源的域名做拆分以达到最大的请求数优化，这就导致需要对这些不同的域名需要做多次 DNS 解析。DNS 请求需要的带宽非常小，但是延迟却有点高，这点在手机网络上特别明显。预读取 DNS 能让延迟明显减少一些，例如用户点击链接时。在某些情况下，延迟能减少一秒钟。 </p><p><code>dns-prefetch</code> 可以让浏览器对相应的域名做预解析处理，提升加载速度。</p><ul><li>打开和关闭 DNS Prefetch</li></ul><pre><code class="html">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;off&quot;&gt;</code></pre><ul><li>强制查询特定主机名</li></ul><pre><code class="html">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.example.com&quot;&gt;</code></pre><p><em>同类的标签属性还有 Preload, Prefetch</em></p><h5 id="3-合理设置缓存"><a href="#3-合理设置缓存" class="headerlink" title="3. 合理设置缓存"></a>3. 合理设置缓存</h5><p>因为缓存的问题比较广泛，这里只提一下，后续更新</p><h5 id="4-减少-HTTP-请求"><a href="#4-减少-HTTP-请求" class="headerlink" title="4. 减少 HTTP 请求"></a>4. 减少 HTTP 请求</h5><ul><li>合并 js/css</li><li>雪碧图</li><li>base 64 图片</li><li>iconfont</li><li>延时加载</li><li>避免空 href 和 src</li></ul><h5 id="5-减少资源体积"><a href="#5-减少资源体积" class="headerlink" title="5. 减少资源体积"></a>5. 减少资源体积</h5><ul><li>gzip 压缩</li><li>html/css/js 压缩</li><li>图片压缩</li><li>图片服务器动态响应</li></ul><h5 id="6-减少页面重定向"><a href="#6-减少页面重定向" class="headerlink" title="6. 减少页面重定向"></a>6. 减少页面重定向</h5><h5 id="7-域名切分"><a href="#7-域名切分" class="headerlink" title="7. 域名切分"></a>7. 域名切分</h5><p>如 #2 描述但是只限 HTTP/1.0 HTTP/1.1 下有意义， HTTP/2.0 后反而会影响页面加载速度</p><h3 id="浏览器解析渲染"><a href="#浏览器解析渲染" class="headerlink" title="浏览器解析渲染"></a>浏览器解析渲染</h3><h5 id="1-合理的-HTML-结构"><a href="#1-合理的-HTML-结构" class="headerlink" title="1. 合理的 HTML 结构"></a>1. 合理的 HTML 结构</h5><ul><li>css 头部加载，js放在尾部</li><li>避免内联样式</li><li>避免使用 @import 加载 css</li></ul><h5 id="2-合理使用异步脚本加载和动态脚本加载"><a href="#2-合理使用异步脚本加载和动态脚本加载" class="headerlink" title="2. 合理使用异步脚本加载和动态脚本加载"></a>2. 合理使用异步脚本加载和动态脚本加载</h5><h5 id="3-触发-GPU-渲染加速"><a href="#3-触发-GPU-渲染加速" class="headerlink" title="3. 触发 GPU 渲染加速"></a>3. 触发 GPU 渲染加速</h5><h3 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h3><h5 id="1-DOM-操作优化（访问-DOM-时耗性能以及避免重排）"><a href="#1-DOM-操作优化（访问-DOM-时耗性能以及避免重排）" class="headerlink" title="1. DOM 操作优化（访问 DOM 时耗性能以及避免重排）"></a>1. DOM 操作优化（访问 DOM 时耗性能以及避免重排）</h5><ul><li>避免频繁操作 DOM</li><li>用 <code>className</code> 代替内联样式修改</li><li>先设置元素为 <code>display：none；</code> 然后进行页面布局等操作；设置完成后将元素设置为 <code>display：block；</code> 这样的话就只引发两次重绘和重排</li><li>不要经常访问浏览器的 <code>flush</code> 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流</li><li>将需要多次重排的元素 <code>position</code> 属性设为 <code>absolute</code> 或 <code>fixed</code>，元素脱离了文档流，它的变化不会影响到其他元素</li><li>如果需要创建多个 DOM 节点，可以使用 <code>DocumentFragment</code> 创建完后一次性的加入 document</li><li>避免强制同步布局和布局抖动</li><li>尽量不要使用 <code>table</code> 布局</li><li>尽量使用 css 动画</li><li>使用 <code>requestAnimationFrame</code> 代替 <code>setInterval</code>、<code>setTimeout</code> 操作</li><li>适当使用 <code>canvas</code></li><li>尽量减少 css 表达式的使用</li></ul><h5 id="2-使用事件委托"><a href="#2-使用事件委托" class="headerlink" title="2. 使用事件委托"></a>2. 使用事件委托</h5><h5 id="3-使用局部变量"><a href="#3-使用局部变量" class="headerlink" title="3. 使用局部变量"></a>3. 使用局部变量</h5><h5 id="4-避免长作用域链"><a href="#4-避免长作用域链" class="headerlink" title="4. 避免长作用域链"></a>4. 避免长作用域链</h5><h5 id="5-高效存储数据"><a href="#5-高效存储数据" class="headerlink" title="5. 高效存储数据"></a>5. 高效存储数据</h5><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><ul><li>浏览器缓存</li><li>Performance</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://www.w3.org/TR/resource-hints/#dns-prefetch" target="_blank" rel="noopener">Resource Hints</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Controlling_DNS_prefetching" target="_blank" rel="noopener">MDN DNS 预读取</a></p>]]></content>
      
      <categories>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端图片压缩上传</title>
      <link href="/2019/03/08/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0/"/>
      <url>/2019/03/08/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<h1 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近业务中遇到了用户抱怨说上传图片时间太长，感觉上是系统特别慢。</p><p>所以打算对图片上传进行优化，前端压缩后再上传文件。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>经过搜索后目前大家常用的图片压缩方案有这么几种</p><ol><li><p><em>canvas</em> 前端压缩 (移动端对 canvas 支持情况较好，能解决现有问题)</p></li><li><p><del>对图片尺寸压缩</del> (打卡需要用户与背景的合照，不能对尺寸压缩会丢失信息)</p></li><li><p><del>上传图片后端压缩</del> (需要解决的问题是上传慢，这种方法不适合当前场景)</p></li></ol><p>对比后我选择了第一种方案，就是 <em>canvas</em> 压缩图片的方案</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><em>有个前提条件 由于项目中是调用用户相机拍照得到的文件，所以我不需要 check 文件类型</em></p><ol><li><p>检查文件大小是否需要压缩</p></li><li><p>使用 FileReader 对图片文件进行读取，并转化为 Base64 编码的 dataURL</p></li><li><p>用上一步得到的 Base64 编码的图片转化为一个 Image DOM 对象 (因为 canvas 的 drawImage 方法传入的参数只支持 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasImageSource" target="_blank" rel="noopener">Canvas​Image​Source</a>)</p></li><li><p>调用 canvas 接口画出图像并转为压缩后的 dataURL</p></li><li><p>将压缩后的文件上传到服务器</p></li></ol><p class="center"><img src="/2019/03/08/前端/前端图片压缩上传/canvasCompress.png" alt="图片压缩"></p><h4 id="file2DataURL-实现"><a href="#file2DataURL-实现" class="headerlink" title="file2DataURL 实现"></a>file2DataURL 实现</h4><pre><code class="JavaScript">// 图片文件转 Base64 编码const file2DataURL = (file, callback) =&gt; {  const reader = new FileReader();  reader.onload = function () {    const dataURL = this.result;    callback(dataURL);  };  reader.readAsDataURL(file);};</code></pre><h4 id="dataURL2Image-实现"><a href="#dataURL2Image-实现" class="headerlink" title="dataURL2Image 实现"></a>dataURL2Image 实现</h4><pre><code class="JavaScript">// dataURL 转 img 对象const dataURL2Image = (dataURL, callback) =&gt; {  const img = new Image();  img.onload = () =&gt; {    callback(img);  };  img.src = dataURL;};</code></pre><h4 id="canvasCompress-实现"><a href="#canvasCompress-实现" class="headerlink" title="canvasCompress 实现"></a>canvasCompress 实现</h4><pre><code class="JavaScript">// canvas 压缩图片const canvasCompress = (img, quality, type) =&gt; {  const canvas = document.createElement(&#39;canvas&#39;);  const { width, height } = img;  canvas.width = width;  canvas.height = height;  const context =  canvas.getContext(&#39;2d&#39;);  context.drawImage(img, 0, 0, width, height);  const compressedDataURL = canvas.toDataURL(type, quality);  return compressedDataURL;};</code></pre><h4 id="dataURL2Blob-实现"><a href="#dataURL2Blob-实现" class="headerlink" title="dataURL2Blob 实现"></a>dataURL2Blob 实现</h4><pre><code class="JavaScript">// dataURL 转 blob 流const dataURL2Blob = (dataURL, type) =&gt; {  const text = window.atob(dataURL.split(&quot;,&quot;)[1]);  const buffer = new ArrayBuffer(text.length);  const ubuffer = new Uint8Array(buffer);  for (let i = 0; i &lt; text.length; i++) {      ubuffer[i] = text.charCodeAt(i);  }  const blob = new window.Blob([buffer], { type });  return blob;};</code></pre><h4 id="compress-实现"><a href="#compress-实现" class="headerlink" title="compress 实现"></a>compress 实现</h4><pre><code class="JavaScript">/** * @param {File} source  图片源文件 * @param {Number} quality 压缩质量 - 默认不压缩 0 ~ 1 * @param {Number} maxSize 大小限制 - 默认 1 MB,（1M以上就要压缩） */const compress = (source, callback, quality = 1, maxSize = 1) =&gt; {  // quality 参数错误不压缩直接返回  if(quality &gt; 1) {    return callback(source);  }  // 单位转换  maxSize = maxSize * 1024 * 1024;  // 对 img 参数做简单的判断;  if(!source || !(source instanceof File)){    return callback(source);  }  // 图片小于限制则不压缩  if(source.size &lt;= maxSize) {    return callback(source);  }  try {    const type = source.type;    file2DataURL(source, (dataURL) =&gt; {      dataURL2Image(dataURL, (img) =&gt; {        const compressedDataURL = canvasCompress(img, quality, type);        const compressedResult = dataURL2Blob(compressedDataURL, type);        compressedResult.fileName = source.name;        callback(compressedResult);      });    });  } catch (e) {    // process error  }};</code></pre><p>目前使用回调的方式调用最终看起来会有点乱，大家也可以优化改成 Promise + async await 的方式这样看起来结构会好很多。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader" target="_blank" rel="noopener">FileReader</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage" target="_blank" rel="noopener">Canvas​Rendering​Context2D.draw​Image()</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL" target="_blank" rel="noopener">HTMLCanvas​Element​.toDataURL()</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener">Blob</a></p>]]></content>
      
      <categories>
          
          <category> 图片压缩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端优化 </tag>
            
            <tag> 图片压缩 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lodash.concat 源码阅读</title>
      <link href="/2019/02/19/Lodash%20%E7%B3%BB%E5%88%97/concat/"/>
      <url>/2019/02/19/Lodash%20%E7%B3%BB%E5%88%97/concat/</url>
      <content type="html"><![CDATA[<h1 id="Lodash-源码阅读（四）"><a href="#Lodash-源码阅读（四）" class="headerlink" title="Lodash 源码阅读（四）"></a>Lodash 源码阅读（四）</h1><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>该方法的效果同 Array.concat</p><p>var array = [1];<br>var other = _.concat(array, 2, [3], [[4]]);<br>console.log(array.concat(2, [3], [[4]]));  // =&gt; [1, 2, 3, [4]]<br>console.log(other);  // =&gt; [1, 2, 3, [4]]</p><pre><code class="JavaScript">import arrayPush from &#39;./_arrayPush.js&#39;;import baseFlatten from &#39;./_baseFlatten.js&#39;;import copyArray from &#39;./_copyArray.js&#39;;import isArray from &#39;./isArray.js&#39;;function concat() {  var length = arguments.length;  if (!length) {    return [];  }  var args = Array(length - 1),      array = arguments[0],      index = length;  while (index--) {    args[index - 1] = arguments[index];  }  return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));}</code></pre><h3 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h3><h4 id="arrayPush"><a href="#arrayPush" class="headerlink" title="_arrayPush"></a>_arrayPush</h4><p>param1: <code>array</code></p><p>param2: <code>values</code></p><p>两个参数均为数组，将第二个数组中每个值 push 到 第一个参数后面</p><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><pre><code class="Javascript">var array = [1, 2, 3, 4];var values = [5, 6, 7, [8], &quot;9&quot;];console.log(arrayPush(array, values)); // [1, 2, 3, 4, 5, 6, 7, [8], &quot;9&quot;]</code></pre><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><pre><code class="Javascript">function arrayPush(array, values) {  var index = -1,      length = values.length,      offset = array.length;  // 循环将 values 里的值挨个放到 array 中并返回 array  while (++index &lt; length) {    array[offset + index] = values[index];  }  return array;}</code></pre><h4 id="copyArray"><a href="#copyArray" class="headerlink" title="_copyArray"></a>_copyArray</h4><p>param1: <code>source</code> 为待复制（浅复制）的数组</p><p>param2: <code>array</code>  为目标数组或为空</p><h5 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h5><pre><code class="Javascript">copyArray([1, 2, 3]); // [1, 2, 3]</code></pre><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><pre><code class="Javascript">function copyArray(source, array) {  var index = -1,      length = source.length;  array || (array = Array(length));  while (++index &lt; length) {    // 浅复制    array[index] = source[index];  }  return array;}</code></pre><h4 id="baseFlatten"><a href="#baseFlatten" class="headerlink" title="_baseFlatten"></a>_baseFlatten</h4><p>param1: <code>array</code> 想要扁平化的数组</p><p>param2: <code>depth</code> 扁平化的深度</p><p>param3: <code>predicate</code> 判断是否需要扁平化的函数</p><p>param4: <code>isStrict</code></p><p>param5: <code>result</code></p><h5 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h5><pre><code class="Javascript">baseFlatten([1, [2], 3, [4, 5, [6, 7]]], 1); // [1, 2, 3, 4, 5, [6, 7]]</code></pre><h5 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h5><pre><code class="Javascript">import arrayPush from &#39;./_arrayPush.js&#39;;import isFlattenable from &#39;./_isFlattenable.js&#39;;function baseFlatten(array, depth, predicate, isStrict, result) {  var index = -1,      length = array.length;  predicate || (predicate = isFlattenable);  result || (result = []);  while (++index &lt; length) {    var value = array[index];    // 如果当前深度大于 0 且当前值是可以扁平化的    if (depth &gt; 0 &amp;&amp; predicate(value)) {      if (depth &gt; 1) {        // 递归去扁平化数组        // Recursively flatten arrays (susceptible to call stack limits).        baseFlatten(value, depth - 1, predicate, isStrict, result);      } else {        // depth === 1 时该函数完成了扁平化，进行赋值操作        arrayPush(result, value);      }    } else if (!isStrict) { // 限制哪些没有通过扁平化测试的值，如果不是严格型的就赋值，如果是严格型的就丢弃      result[result.length] = value;    }  }  return result;}</code></pre><h4 id="isFlattenable"><a href="#isFlattenable" class="headerlink" title="_isFlattenable"></a>_isFlattenable</h4><p>param1: <code>value</code> 待判断是否可以做扁平化操作的值</p><h5 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h5><pre><code class="Javascript">import Symbol from &#39;./_Symbol.js&#39;;import isArguments from &#39;./isArguments.js&#39;;import isArray from &#39;./isArray.js&#39;;/** Built-in value references. */var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;function isFlattenable(value) {  return isArray(value) || isArguments(value) ||    !!(spreadableSymbol &amp;&amp; value &amp;&amp; value[spreadableSymbol]);}</code></pre>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Lodash </tag>
            
            <tag> concat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lodash.compact 源码阅读</title>
      <link href="/2019/02/18/Lodash%20%E7%B3%BB%E5%88%97/compact/"/>
      <url>/2019/02/18/Lodash%20%E7%B3%BB%E5%88%97/compact/</url>
      <content type="html"><![CDATA[<h1 id="Lodash-源码阅读（三）"><a href="#Lodash-源码阅读（三）" class="headerlink" title="Lodash 源码阅读（三）"></a>Lodash 源码阅读（三）</h1><h2 id="compact"><a href="#compact" class="headerlink" title="compact"></a>compact</h2><p>将一个数组变为紧凑数组</p><p>Creates an array with all falsey values removed. The values <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, and <code>NaN</code> are falsey.</p><p>其思想就是将传进来的数组做一个循环，把所有不是 falsey 的部分挨个放到新的数组中。</p><pre><code class="JavaScript">function compact(array) {  var index = -1,      length = array == null ? 0 : array.length,   // 对 length 有效值做处理      resIndex = 0,      result = [];  // 对传参的数组做循环  while (++index &lt; length) {    var value = array[index];    if (value) {      // 将非 falsey 的值放到新数组 result 里      result[resIndex++] = value;    }  }  return result;}</code></pre><h2 id="自己的简单实现"><a href="#自己的简单实现" class="headerlink" title="自己的简单实现"></a>自己的简单实现</h2><pre><code class="JavaScript">function compact(array) {  // array  if (array == null) {    return [];  }  return array.filter(value =&gt; value);}</code></pre>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Lodash </tag>
            
            <tag> compact </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lodash.slice &amp; Lodash.chunk 源码阅读</title>
      <link href="/2019/02/14/Lodash%20%E7%B3%BB%E5%88%97/slice%20&amp;%20chunk/"/>
      <url>/2019/02/14/Lodash%20%E7%B3%BB%E5%88%97/slice%20&amp;%20chunk/</url>
      <content type="html"><![CDATA[<h1 id="Lodash-源码阅读（二）"><a href="#Lodash-源码阅读（二）" class="headerlink" title="Lodash 源码阅读（二）"></a>Lodash 源码阅读（二）</h1><h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p>参数 <code>array</code> 为 数组类型， <code>start</code> 和 <code>end</code> 数字。</p><p>输出数组第 <code>start</code> 个值到 第 <code>end</code> 个值组成的数组，非法时时空数组。（<code>start</code>, <code>end</code> 不是索引值，而是<em>字面意义</em>的数组中的<code>第 N 个值</code>）</p><pre><code class="JavaScript">function slice(array, start, end) {  // array 长度为 0 或不存在直接返回空数组  let length = array == null ? 0 : array.length  if (!length) {    return []  }  // start 默认值 0  start = start == null ? 0 : start  // end 默认值为 数组长度  end = end === undefined ? length : end  if (start &lt; 0) {    // start &lt; 0 时的特殊处理    // 目的使 start 在 0 ~ length 的范围内    start = -start &gt; length ? 0 : (length + start)  }  // end 大于数组长度时修改值为数组长度  end = end &gt; length ? length : end  // end &lt; 0 时的特殊处理  if (end &lt; 0) {    end += length  }  // start 和 end 都在范围内后判断 length 的长度，如果 start &gt; end 非法则输出空数组  length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0)  // start 取整，因为 start 在小于零时已特殊处理为正数。若 start 此时为负数则不可用 &gt;&gt;&gt; 取整  start &gt;&gt;&gt;= 0  let index = -1  // 分配内存  const result = new Array(length)  // index 0 ~ length  while (++index &lt; length) {    // 循环赋值    result[index] = array[index + start]  }  return result}</code></pre><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>将一个数组按固定大小(<code>size</code>)分割，例如：</p><ul><li>chunk([‘a’, ‘b’, ‘c’, ‘d’], 2) 输出为 [[‘a’, ‘b’], [‘c’, ‘d’]]</li><li>chunk([‘a’, ‘b’, ‘c’, ‘d’], 3) 输出为 [[‘a’, ‘b’, ‘c’], [‘d’]]</li></ul><pre><code class="JavaScript">function chunk(array, size) {  // size 最小为 0  size = Math.max(size, 0)  const length = array == null ? 0 : array.length  // length ”小于“ 1 或 size ”小于“ 1 返回空数组  if (!length || size &lt; 1) {    return []  }  let index = 0  let resIndex = 0  // 分配内存，数组长度 按 length / size 向上取整  const result = new Array(Math.ceil(length / size))  while (index &lt; length) {    // 循环为 result 赋值    result[resIndex++] = slice(array, index, (index += size))  }  return result}</code></pre><h5 id="浏览器调用"><a href="#浏览器调用" class="headerlink" title="浏览器调用"></a>浏览器调用</h5><p>因为我没有找到在线使用 <code>lodash</code> 的网站，下面这段代码只是为了方便自己在浏览器里调用 <code>lodash</code> 的方法，加深理解。 </p><pre><code class="Javascript">var script = document.createElement(&#39;script&#39;);script.src = &quot;https://cdn.bootcss.com/lodash.js/4.17.11/lodash.js&quot;;document.body.appendChild(script);</code></pre>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Lodash </tag>
            
            <tag> slice </tag>
            
            <tag> chunk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lodash.debounce 源码阅读</title>
      <link href="/2019/01/25/Lodash%20%E7%B3%BB%E5%88%97/debounce/"/>
      <url>/2019/01/25/Lodash%20%E7%B3%BB%E5%88%97/debounce/</url>
      <content type="html"><![CDATA[<h1 id="Lodash-源码阅读（一）"><a href="#Lodash-源码阅读（一）" class="headerlink" title="Lodash 源码阅读（一）"></a>Lodash 源码阅读（一）</h1><h2 id="前言小絮叨"><a href="#前言小絮叨" class="headerlink" title="前言小絮叨"></a>前言小絮叨</h2><p>距离上次写博客已经过了大概 4 个月了，自从到了贝壳业务越来越多，一到周末就累得什么也不想干。最近刚忙完 H5 的项目（😝后续可以来一篇企微浏览器使用蓝牙的小总结感觉很有意思）又接近年关 OP 封板停止发布。虽然需求也在排着，但是想写写自己的东西。</p><h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><p><code>debounce</code> 就是函数防抖，当函数一直被触发时等到 waiting 时间到了之后再执行，常见用法就是防止用户多次点击或者当一个函数会频繁触发而又没有必要调用那么多次时使用该函数（或函数节流）以优化性能。</p><h2 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h2><pre><code class="JavaScript">// lodash debouncefunction debounce(func, wait, options) {  let lastArgs,    lastThis,    maxWait,    result,    timerId,    lastCallTime  let lastInvokeTime = 0 // 上一次执行时间  let leading = false    // 开始是否执行  let maxing = false     // 是否有最大等待时间  let trailing = true    // 结束是否执行  // Bypass `requestAnimationFrame` by explicitly setting `wait=0`.  // 是否使用 requestAnimationFrame  // 当忽略 wait 时会使用 requestAnimationFrame 下一帧时就调用函数。（16ms）  const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof root.requestAnimationFrame === &#39;function&#39;)  // 如果 func 不是函数直接抛出错误  if (typeof func != &#39;function&#39;) {    throw new TypeError(&#39;Expected a function&#39;)  }  // 获取配置项  // +arg 类似一个简单的 toNumber(arg)  wait = +wait || 0  if (isObject(options)) {    leading = !!options.leading    maxing = &#39;maxWait&#39; in options    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait    trailing = &#39;trailing&#39; in options ? !!options.trailing : trailing  }  // 调用 func  function invokeFunc(time) {          // time 调用时的时间戳    const args = lastArgs              // 调用的参数    const thisArg = lastThis           // 调用的 this    lastArgs = lastThis = undefined    // 清除 lastArgs 和 lastThis    lastInvokeTime = time              // 记录调用时间    result = func.apply(thisArg, args) // 调用 func 并将结果返回    return result  }  // 开始计时  function startTimer(pendingFunc, wait) {    if (useRAF) {      return root.requestAnimationFrame(pendingFunc)    }    return setTimeout(pendingFunc, wait)  }  // 取消计时  function cancelTimer(id) {    if (useRAF) {      return root.cancelAnimationFrame(id)    }    clearTimeout(id)  }  // 延时前调用  function leadingEdge(time) {    // Reset any `maxWait` timer.    lastInvokeTime = time    // Start the timer for the trailing edge.    timerId = startTimer(timerExpired, wait)    // Invoke the leading edge.    return leading ? invokeFunc(time) : result  }  // 设置需要等待时间  function remainingWait(time) {    const timeSinceLastCall = time - lastCallTime     // 距上次触发的时间    const timeSinceLastInvoke = time - lastInvokeTime // 距上次调用 func 的时间    const timeWaiting = wait - timeSinceLastCall      // 还需等待的时间    return maxing      ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)      : timeWaiting  }  // 判断是否应该被调用  function shouldInvoke(time) {    const timeSinceLastCall = time - lastCallTime    const timeSinceLastInvoke = time - lastInvokeTime    // Either this is the first call, activity has stopped and we&#39;re at the    // trailing edge, the system time has gone backwards and we&#39;re treating    // it as the trailing edge, or we&#39;ve hit the `maxWait` limit.    return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) ||      (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait))  }  // 刷新 timer  function timerExpired() {    const time = Date.now()    if (shouldInvoke(time)) {      return trailingEdge(time)    }    // Restart the timer.    timerId = startTimer(timerExpired, remainingWait(time))  }  // 延时后调用  function trailingEdge(time) {    timerId = undefined    // Only invoke if we have `lastArgs` which means `func` has been    // debounced at least once.    // 配置中 trailing 为 true 且有 lastArgs（func 被执行过一次）    if (trailing &amp;&amp; lastArgs) {      return invokeFunc(time)    }    lastArgs = lastThis = undefined    return result  }  // 取消执行  function cancel() {    if (timerId !== undefined) {      cancelTimer(timerId)    }    lastInvokeTime = 0    lastArgs = lastCallTime = lastThis = timerId = undefined  }  // 直接执行  function flush() {    return timerId === undefined ? result : trailingEdge(Date.now())  }  // 等待  function pending() {    return timerId !== undefined  }  function debounced(...args) {    const time = Date.now()    const isInvoking = shouldInvoke(time)        // 判断是否可调用    lastArgs = args                              // 获取参数    lastThis = this                              // 获取调用时的 this    lastCallTime = time                          // 触发时间    if (isInvoking) {      if (timerId === undefined) {               // 首次触发调用 leadingEdge        return leadingEdge(lastCallTime)      }      if (maxing) {        // Handle invocations in a tight loop.        // 处理频繁的多次调用        timerId = startTimer(timerExpired, wait) // 设置定时器        return invokeFunc(lastCallTime)      }    }    if (timerId === undefined) {                 // 如果没有 timer 设置定时器      timerId = startTimer(timerExpired, wait)    }    return result  }  debounced.cancel = cancel  debounced.flush = flush  debounced.pending = pending  return debounced}</code></pre>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Lodash </tag>
            
            <tag> debounce </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>EventEmitter 源码阅读</title>
      <link href="/2018/08/27/JavaScript/EventEmitter-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2018/08/27/JavaScript/EventEmitter-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      <content type="html"><![CDATA[<p>上周看了 <a href="https://github.com/Olical/EventEmitter" target="_blank" rel="noopener">EventEmitter</a> 的源码，这篇博客打算做个小结（不是 Node 的源码，只是 github 上搜到的星星最多的项目，还有个项目 <a href="https://github.com/primus/eventemitter3" target="_blank" rel="noopener">EventEmitter3</a> 项目作者目前依然在维护，主打性能，看起来非常不错）</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><pre><code class="JavaScript">;(function(exports) {    &#39;use strict&#39;;    function EventEmitter() {}    var proto = EventEmitter.prototype;    var originalGlobalValue = exports.EventEmitter;    /**     * 工具函数     * indexOfListener     * alias     * isValidListener     */    /**     * 方法实现     */    EventEmitter.noConflict = function() {        exports.EventEmitter = originalGlobalValue;        return EventEmitter;    }    if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {        define(function() {            return EventEmitter;        });    } else if (typeof module === &#39;object&#39; &amp;&amp; module.exports){        module.exports = EventEmitter;    } else {        exports.EventEmitter = EventEmitter;    }}(typeof window !== &#39;undefined&#39; ? window : this || {}));</code></pre><h3 id="最外层的自执行"><a href="#最外层的自执行" class="headerlink" title="最外层的自执行"></a>最外层的自执行</h3><pre><code class="JavaScript">;(function(exports){  // some code  }(typeof window !== &#39;undefined&#39; ? window : this || {}));</code></pre><p><strong>0. 闭包</strong></p><p>避免全区变量污染，私有作用域… 就是闭包的常规用途</p><p><strong>1. 开头的分号</strong></p><p>为了防止打包或则其他工具合并 js 代码并压缩的时候由于前面没有以分号结尾而出错，比如这种情况 <code>var a = someFunction</code></p><p>如果不加分号则会变成 <code>var a = someFunction( function(){}() )</code>，这可能导致意外。</p><p><strong>2. context 以 export 为变量名传入函数</strong></p><p>可以在代码压缩时减小 size，将全局的 window 传入可以避免内部使用 window 进行查询时由作用域链向上多找一级。</p><p><strong>3. 类的实现</strong></p><p>利用函数的原型链模拟，先创建一个空函数 <code>function EventEmitter() {}</code>，然后将该类的方法挂载到 <code>EventEmitter.prototype</code> 上面。</p><p><strong>4. 对于冲突的处理</strong></p><pre><code class="JavaScript">    var originalGlobalValue = exports.EventEmitter;    EventEmitter.noConflict = function() {        exports.EventEmitter = originalGlobalValue;        return EventEmitter;    }</code></pre><p>先将全局的 <code>EventEmitter</code> 保存到一个变量 <code>originalGlobalValue</code> 中。执行 <code>noConflict</code> 后再将 <code>originalGlobalValue</code> 还给全局的 <code>EventEmitter</code>，并返回这个库所实现的 <code>EventEmitter</code>。</p><p>例如：</p><pre><code class="JavaScript">var EventEmitter = function a() {}// load myEventEmitter.js// 此时 EventEmitter = myEventEmitter;var b = EventEmitter.noConflict();// 此时 EventEmitter = function a() {}// b = myEventEmitter</code></pre><p><strong>5. 对于模块化的处理</strong></p><pre><code class="JavaScript">// 兼容 AMDif (typeof define === &#39;function&#39; &amp;&amp; define.amd) {        define(function() {            return EventEmitter;        });    }    // 兼容 CommonJS    else if (typeof module === &#39;object&#39; &amp;&amp; module.exports){        module.exports = EventEmitter;    } else {        exports.EventEmitter = EventEmitter;    }</code></pre><p>这个库的整体结构并不复杂，基本上看过 jQuery 源码或则对一些常用的模块化方法有基本了解都能理解</p><h2 id="工具函数的实现"><a href="#工具函数的实现" class="headerlink" title="工具函数的实现"></a>工具函数的实现</h2><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><pre><code class="JavaScript">/** * Alias a method while keeping the context correct, to allow for overwriting of target method. * * @param {String} name The name of the target method. * @return {Function} The aliased method * @api private */function alias(name) {    return function aliasClosure() {        return this[name].apply(this, arguments);    };}</code></pre><p>这么调用 <code>EventEmitter.prototype.on = alise(&#39;addListener&#39;)</code>。<br>可是为什么要多此一举？ 而不直接用 <code>EventEmitter.prototype.on = EventEmitter.prototype.addListener</code></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>isValidListener(listener) 就是判断 listener 是不是合法</p><p>indexOfListener(listeners: Function[], listener: Function) 就是在数组中找到对应项的 listener 属性和第二个参数 Function 全等的项并返回索引值</p><h2 id="核心方法的实现"><a href="#核心方法的实现" class="headerlink" title="核心方法的实现"></a>核心方法的实现</h2><h3 id="getEvents"><a href="#getEvents" class="headerlink" title="_getEvents"></a>_getEvents</h3><pre><code class="JavaScript">/** * Fetches the events object and creates one if required. * * @return {Object} The events storage object. * @api private */proto._getEvents = function _getEvents() {    return this._events || (this._events = {});};</code></pre><p>取 <code>_event</code> 属性如果不存在就创建一个空对象赋值给 <code>_event</code> 并返回。</p><h3 id="getListeners"><a href="#getListeners" class="headerlink" title="getListeners"></a>getListeners</h3><pre><code class="JavaScript">/** * Returns the listener array for the specified event. * Will initialise the event object and listener arrays if required. * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them. * Each property in the object response is an array of listener functions. * * @param {String|RegExp} evt Name of the event to return the listeners from. * @return {Function[]|Object} All listener functions for the event. */proto.getListeners = function getListeners(evt) {    var events = this._getEvents();    var response;    var key;    // Return a concatenated array of all matching events if    // the selector is a regular expression.    // 支持正则查询， 如果没查询到返回空对象 {}    if (evt instanceof RegExp) {        response = {};        for (key in events) {            if (events.hasOwnProperty(key) &amp;&amp; evt.test(key)) {                response[key] = events[key];            }        }    }    else {        response = events[evt] || (events[evt] = []); // 如果不存在就初始化 _this.event[evt] 为 []    }    return response;};</code></pre><h3 id="addListener"><a href="#addListener" class="headerlink" title="addListener"></a>addListener</h3><pre><code class="JavaScript">/** * Adds a listener function to the specified event. * The listener will not be added if it is a duplicate. * If the listener returns true then it will be removed after it is called. * If you pass a regular expression as the event name then the listener will be added to all events that match it. * * @param {String|RegExp} evt Name of the event to attach the listener to. * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling. * @return {Object} Current instance of EventEmitter for chaining. * * 1. 先判断要添加的 listener 是否合法 * 2. 获取当前符合条件的 listener * 3. 判断要添加的 listener 是否已经存在 * 4. 如果不存在 就将 listener 包裹成固定的格式起来放入 listeners 中 */proto.addListener = function addListener(evt, listener) {    if (!isValidListener(listener)) {        throw new TypeError(&#39;listener must be a function&#39;);    }    var listeners = this.getListenersAsObject(evt);    var listenerIsWrapped = typeof listener === &#39;object&#39;;    var key;    for (key in listeners) {        if (listeners.hasOwnProperty(key) &amp;&amp; indexOfListener(listeners[key], listener) === -1) {            listeners[key].push(listenerIsWrapped ? listener : {                listener: listener,                once: false            });        }    }    return this;};</code></pre><h3 id="removeListener"><a href="#removeListener" class="headerlink" title="removeListener"></a>removeListener</h3><pre><code class="JavaScript">/** * Removes a listener function from the specified event. * When passed a regular expression as the event name, it will remove the listener from all events that match it. * * @param {String|RegExp} evt Name of the event to remove the listener from. * @param {Function} listener Method to remove from the event. * @return {Object} Current instance of EventEmitter for chaining. */// 删除事件订阅// 1. 找到所有的符合 evt 规则的事件// 2. 循环找出事件在 events 中的索引并 splice 删除proto.removeListener = function removeListener(evt, listener) {    var listeners = this.getListenersAsObject(evt);    var index;    var key;    for (key in listeners) {        if (listeners.hasOwnProperty(key)) {            index = indexOfListener(listeners[key], listener);            if (index !== -1) {                listeners[key].splice(index, 1);            }        }    }    return this;};</code></pre><h3 id="removeEvent"><a href="#removeEvent" class="headerlink" title="removeEvent"></a>removeEvent</h3><pre><code class="JavaScript">/** * Removes all listeners from a specified event. * If you do not specify an event then all listeners will be removed. * That means every event will be emptied. * You can also pass a regex to remove all events that match it. * * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed. * @return {Object} Current instance of EventEmitter for chaining. *//** * 删除事件 * 1. 判断 evt 类型 * 如果是 字符串 就直接删除 _events 中对应的属性 * 如果是 正则表达式 就删除符合正则的 _events 中对应的属性 * 如果都不是 就删除全部事件 */proto.removeEvent = function removeEvent(evt) {    var type = typeof evt;    var events = this._getEvents();    var key;    // Remove different things depending on the state of evt    if (type === &#39;string&#39;) {        // Remove all listeners for the specified event        delete events[evt];    }    else if (evt instanceof RegExp) {        // Remove all events matching the regex.        for (key in events) {            if (events.hasOwnProperty(key) &amp;&amp; evt.test(key)) {                delete events[key];            }        }    }    else {        // Remove all listeners in all events        delete this._events;    }    return this;};</code></pre><h3 id="emitEvent"><a href="#emitEvent" class="headerlink" title="emitEvent"></a>emitEvent</h3><pre><code class="JavaScript">/** * Emits an event of your choice. * When emitted, every listener attached to that event will be executed. * If you pass the optional argument array then those arguments will be passed to every listener upon execution. * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately. * So they will not arrive within the array on the other side, they will be separate. * You can also pass a regular expression to emit to all events that match it. * * @param {String|RegExp} evt Name of the event to emit and execute listeners for. * @param {Array} [args] Optional array of arguments to be passed to each listener. * @return {Object} Current instance of EventEmitter for chaining. *//** * 触发事件 * 1. 找到 符合条件的事件 * 2. 依次调用 * 3. 判断是否是一次调用，如果是就删除事件 */proto.emitEvent = function emitEvent(evt, args) {    var listenersMap = this.getListenersAsObject(evt);    var listeners;    var listener;    var i;    var key;    var response;    for (key in listenersMap) {        if (listenersMap.hasOwnProperty(key)) {            listeners = listenersMap[key].slice(0);            for (i = 0; i &lt; listeners.length; i++) {                // If the listener returns true then it shall be removed from the event                // The function is executed either with a basic call or an apply if there is an args array                listener = listeners[i];                if (listener.once === true) {                    this.removeListener(evt, listener.listener);                }                response = listener.listener.apply(this, args || []);                if (response === this._getOnceReturnValue()) {                    this.removeListener(evt, listener.listener);                }            }        }    }    return this;};</code></pre><h3 id="全部方法"><a href="#全部方法" class="headerlink" title="全部方法"></a>全部方法</h3><ul><li>_getEvents</li><li>_getOnceReturnValue</li><li>getListeners</li><li>flattenListeners</li><li>getListenersAsObject</li><li>addListener || on</li><li>addOnceListener || once</li><li>defineEvent</li><li>defineEvents</li><li>removeListener || off</li><li>addListeners</li><li>removeListeners</li><li>manipulateListeners</li><li>removeEvent || removeAllListeners</li><li>emitEvent || trigger</li><li>emit</li><li>setOnceReturnValue</li></ul><p><strong>之后可以自造一个实现该功能的轮子</strong></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> EventEmitter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端小总结</title>
      <link href="/2018/08/23/%E7%94%9F%E6%B4%BB/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/23/%E7%94%9F%E6%B4%BB/%E5%89%8D%E7%AB%AF%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="面试小总结？"><a href="#面试小总结？" class="headerlink" title="面试小总结？"></a>面试小总结？</h2><p>面试题暂且不说，技术相关都差不多。</p><p>面试结果：今年五月面了 3 家公司，两家给了 offer（有点记不得名称）， 由于薪资不符合预期，遂罢。今年 8 月 面了 5 家公司，4 家给了 offer（<del>XC</del>, SK, LJ, HHXX, JZKJ）。</p><p>重点在于面试的这些家只有一家一线互联网公司，很多大公司公司连简历这关都过不了。</p><p>总结下来有 3 点原因吧，为什么不够优秀？</p><ol start="0"><li><p>技术菜~</p></li><li><p>学历不好，非985， 211 学校，非计算机专业</p></li><li><p>简历没有亮点</p></li><li><p>工作年限不足</p></li></ol><h3 id="学历"><a href="#学历" class="headerlink" title="学历"></a>学历</h3><p>这是我永远也摆脱不掉的，投了大厂简历却没有后续面试。找工作的过程中让我一度考虑自己是不是真的需要去考研，而且必须是名校的研究生。</p><p>当然这个决定要早点做。赚钱什么时候都不迟，而学习过了应有年纪以后就会有压力了。</p><p>目前不排除再工作一段时间后就专心复习考研的计划！19年重点项目 O(∩_∩)O</p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>这点我已经努力的在改，我的第一版简历简直不能看，稍微按 STAR 法则修改了一下，好了一些但还是一坨 *。</p><p>8 月 JZKJ 3 轮技术面，其中有个技术主管面试的时候聊，说道：“哎，你的简历不能多写点么，完全…找不到…亮点，虽然从笔试题看来你的基础比较扎实，人也比较上劲，但是简历没有亮点就是减分。”</p><p>我只能苦笑了下。简历这一关在第一条没有任何优势的前提下就更加需要我好好准备了。多写项目相关，岗位相关经历，不相关的奖项经历能不写就不写，切记！</p><h3 id="工作经验"><a href="#工作经验" class="headerlink" title="工作经验"></a>工作经验</h3><p>目前正式工作经验确实只有 1.5 年， 而毕业后的工作经验只有 1 年。所以有些公司面试看了我的工作经验只把我当做初级的工程师，问的知识也比较基础。而正式一些的公司会比较深入会触探我的知识边界。</p><p>当然有的 HR 还会因为工作年限这一条去压你的工资。 5 月面的一家就说，我毕业后到工作还不到一年，完全开不了我要的价格。</p><p>这些都不是重点，重点在于一些一线互联网公司，完全不给面试机会！工作经验 3 年起步。有些还好比如 XC 面试下来感觉还不错，但是后续询问结果的时候告诉我候选人面试都差不多，但是另一个工作经验比我久，就把我的 offer 抢去了TAT。经验 = 踩坑 = 相对靠谱 = 入职成本低，这也是社招不可避免的。</p><p>不找理由，最主要的还是自身不够优秀。当足够优秀的时候，别人一定会因为你的某个闪光点而忽略掉你的学历，你的工作经验。</p><h2 id="以后"><a href="#以后" class="headerlink" title="以后"></a>以后</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><p>前端接触下来近几年的变化应该不会很大，三大框架目前解决了大部分的开发痛点。打算完全阅读某一框架源码，吃透。这一点非常有必要。</p><p>读源码学习的过程，一方面可以理解作者的思路，更好地学习框架的精髓，一方面提升自己的大局观。</p><p>避免闭门造车，只写自己的代码，完全不知道好是什么样，差是什么样。只有见过了优秀的代码，才知道自己写的是什么水平。</p><h3 id="全栈"><a href="#全栈" class="headerlink" title="全栈"></a>全栈</h3><p>利用时间学习一下 Java。</p><p>正好新公司的 Server 框架是 Java 框架，前端业务我有信心不至于压的我一点时间都没有去学习一门新的语言。</p><p>了解至少两种 MySQL 数据库。以前只会写一些简单的 SQL 查询语句，前段时间有简单学习数据库一下才知道 MySQL 也分为很多种，而每一种所应用的场景也有所不同，至少了解一下这些数据库的特点。</p><h3 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h3><p>因为我不是计算机专业，所以有些特别重要的基础需要去填。</p><p>下面是针对我自己列出的优先级顺序，短期就以本科生学习这些课程时间来要求自己务必在下次换工作时这些不能成为我的短板。</p><ol><li><p>数据结构与算法</p></li><li><p>编译原理</p></li><li><p>操作系统</p></li><li><p>数据库原理</p></li><li><p>HTTP/HTTP2/HTTPS（目前知识储备够用，优先级靠后，还需深入理解）</p></li></ol><h3 id="如果你只是一条咸鱼，那也请你做最咸的那条。"><a href="#如果你只是一条咸鱼，那也请你做最咸的那条。" class="headerlink" title="如果你只是一条咸鱼，那也请你做最咸的那条。"></a>如果你只是一条咸鱼，那也请你做最咸的那条。</h3>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oh My iPhone</title>
      <link href="/2018/08/20/%E7%94%9F%E6%B4%BB/Oh-My-iPhone/"/>
      <url>/2018/08/20/%E7%94%9F%E6%B4%BB/Oh-My-iPhone/</url>
      <content type="html"><![CDATA[<p>这是一篇我对数码产品的小随笔吧。</p><p>一切源于一个 2016 年底（12月吧）买的一部 iPhone 7。当时想着可以多用几年所以还上了 128G，但是上个星期它几近退休，今早决定，让他退休吧~</p><p>我对数码产品比较喜欢尝鲜，而又不大爱惜，大学时几乎是一年一部手机，还是感叹我的第一部手机 魅族 M9 用了将近 4 年，从 11 年一直用到大二下学期，直到后来电池坏掉了才让它退休。（可能用的比较小心吧）</p><p>之后又买了 魅族MX4，诺基亚 Lumia 930, 魅蓝 M3， iPhone 7。</p><p>除了第一部手机我用的比较仔细，其余的手机用的都特别随意，掉了磕了是常事。</p><p>这部 iPhone 7 碎了 3 次屏幕，后壳弯掉，也都怪我自己没有控制好情绪，摔了一次之后就没有好好爱护，一直磕磕碰碰。上周自己换好了屏幕，后壳弯着难受，打算换后壳 + 无线充电。所以网上淘了一个。事情就是这么神奇，倒腾了两次，发现应该是尾插排线被我弄坏了，目前还不确定是主板的尾插坏了还是单纯的尾插坏掉了。打算之后去店里让别人修一下当做备用机了。</p><p>然而我看了下某宝全新 iPhone 7 才 3000。而我在这部手机上的维修价格已经将近 2K 了。所以以后修手机的时候还是要看下值不值得吧。</p><p>对于以前报废的手机我打算全部拆掉弄成一个相框一样的东西。</p><p>像这样：</p><p class="center"><img src="/2018/08/20/生活/Oh-My-iPhone/WTF.jpg" alt="WTF"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>不要对手机作恶~</p></li><li><p>不要拿钱不当钱~</p></li><li><p>爱生活，爱手机~</p></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>#NULL#</title>
      <link href="/2018/07/24/%E7%94%9F%E6%B4%BB/NULL/"/>
      <url>/2018/07/24/%E7%94%9F%E6%B4%BB/NULL/</url>
      <content type="html"><![CDATA[<p><style>                                                                                                                                                                                                                                                                                                                                                                                                                                      #null p{text-align: center;font-size: 20px; font-weight: 700} #null p.null{color:#fff;}</style></p><div id="null"><br><p>有人说</p><br><p>等一个无心与你的人</p><br><p>就好像</p><br><p>在机场等一艘船</p><br><p>但是</p><br><p>你是知道么</p><br><p class="null">威尼斯的机场</p><br><p class="null">是可以等到船的</p><br></div>]]></content>
      
      
    </entry>
    
    <entry>
      <title>JS 基础之：String</title>
      <link href="/2018/07/12/JavaScript/String/"/>
      <url>/2018/07/12/JavaScript/String/</url>
      <content type="html"><![CDATA[<p>之前也有总结和重新学习 <strong>String</strong> 的所有方法。长时间不去记忆又有所忘记。今天用博客的方式记录下来，最后用一个思维导图的形式记下来串联起来，巩固自己的记忆。</p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="String-length"><a href="#String-length" class="headerlink" title="String.length"></a>String.length</h3><p>返回一个字符串的长度。这个无需多讲。只是要记住静态的 <code>String.length</code> 值为 <code>1</code>。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="String-prototype-indexOf"><a href="#String-prototype-indexOf" class="headerlink" title="String.prototype.indexOf()"></a>String.prototype.indexOf()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.indexOf(searchValue[, fromIndex])</strong></p></blockquote><p><strong>indexOf()</strong> 方法返回调用 String 对象中从 fromIndex 开始从左向右搜索直到第一次出现指定值的索引位置。如果未找到，返回 -1。</p><p><code>searchValue</code><br>表示需要被查找的字符串</p><p><code>fromIndex</code><br>表示从 <code>str</code> 的这个位置开始向后查找，可以是任意整数（如果是小数则只保留整数部分）。默认值是 <code>0</code>。如果该值小于 <code>0</code> 则当做 <code>0</code>，如果该值大于字符串长度则返回 <code>-1</code>，除非 <code>searchValue = &quot;&quot;</code> 此时返回 <code>str.length</code>。</p><pre><code class="JavaScript">// fromIndex 的内部机制可以用如下伪代码表示：String.prototype.indexOf = function(searchValue, fromIndex) {    fromIndex = fromIndex || 0; // 默认值为 0    // 如果 fromIndex 大于字符串长度    // 则判断需查找字符串是不是空字符串    // 如果是则返回 str.length，如果不是则返回 -1。    if (fromIndex &gt; this.length) {        return searchValue === &quot;&quot; ? this.length : -1;    }    // 如果 fromIndex 小于 0 则当做 0    if (fromIndex &lt; 0) {         fromIndex = 0    }    fromIndex = fromIndex &gt;&gt;&gt; 0; // 取整}</code></pre><hr><h3 id="String-prototype-lastIndexOf"><a href="#String-prototype-lastIndexOf" class="headerlink" title="String.prototype.lastIndexOf()"></a>String.prototype.lastIndexOf()</h3><p>与 <code>indexOf</code> 相似不过是从右向左搜索。</p><p><strong>语法</strong></p><blockquote><p><strong>str.lastIndexOf(searchValue[, fromIndex])</strong></p></blockquote><p><strong>lastIndexOf()</strong> 方法返回调用 String 对象中从 fromIndex 开始从右向左搜索直到第一次出现指定值的索引位置。如果未找到，返回 -1。</p><p><code>searchValue</code><br>表示需要被查找的字符串</p><p><code>fromIndex</code><br>表示从 <code>str</code> 的这个位置开始向后查找，可以是任意整数（如果是小数则只保留整数部分）。默认值是 <code>str.length</code>。如果该值小于 <code>0</code> 则返回 <code>-1</code>，除非 <code>searchValue = &quot;&quot;</code> 此时返回 <code>0</code>。如果该值大于字符串长度当做 <code>str.length</code>。</p><!--```JavaScript// fromIndex 的内部机制可以用如下伪代码表示：String.prototype.lastIndexOf = function(searchValue, fromIndex) {    fromIndex = fromIndex || this.length; // 默认值为 str.length    // 如果 fromIndex 小于 0    // 则判断需查找字符串是不是空字符串    // 如果是则返回 0，如果不是则返回 -1。    if (fromIndex < 0) {        return searchValue === "" ? this.length : -1;    }    // 如果 fromIndex 大于 str.length 则当做 str.length    if (fromIndex > str.length) {         fromIndex = str.length;    }    fromIndex = fromIndex >>> 0; // 取整}```--><hr><h3 id="String-prototype-includes"><a href="#String-prototype-includes" class="headerlink" title="String.prototype.includes()"></a>String.prototype.includes()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.includes(searchString[, position])</strong></p></blockquote><p><code>includes()</code> 方法用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</p><p><code>searchString</code><br>要搜索的子字符串。</p><p><code>position</code><br>从当前字符串的该索引位置开始搜寻子字符串，默认值为0。</p><p><strong>Polyfill</strong></p><pre><code class="JavaScript">if(!String.prototype.includes) {    String.prototype.includes = function(searchString, position) {        &#39;use strict&#39;;        if (typeof position !== &#39;number&#39;) {            position = 0;        }        if (position + searchString.length &gt; this.length) {            return false;        } else {            return this.indexOf(searchString, position) !== -1;        }    }}</code></pre><hr><h3 id="String-prototype-startsWith"><a href="#String-prototype-startsWith" class="headerlink" title="String.prototype.startsWith()"></a>String.prototype.startsWith()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.startsWith(searchString [, position]);</strong></p></blockquote><p><code>startsWith()</code> 方法用来判断当前字符串是否是以另外一个给定的子字符串开头。</p><p><code>searchString</code><br>要搜索的子字符串</p><p><code>position</code><br>在 str 中搜索 searchString 的开始位置，默认值为 <code>0</code>，也就是真正的字符串开头处。</p><p><strong>Polyfill</strong></p><pre><code class="JavaScript">if (!String.prototype.startsWith) {  (function() {    &#39;use strict&#39;; // needed to support `apply`/`call` with `undefined`/`null`    var defineProperty = (function() {      // IE 8 only supports `Object.defineProperty` on DOM elements      try {        var object = {};        var $defineProperty = Object.defineProperty;        var result = $defineProperty(object, object, object) &amp;&amp; $defineProperty;      } catch(error) {}      return result;    }());    var toString = {}.toString;    var startsWith = function(search) {      if (this == null) {        throw TypeError();      }      var string = String(this);      if (search &amp;&amp; toString.call(search) == &#39;[object RegExp]&#39;) {        throw TypeError();      }      var stringLength = string.length;      var searchString = String(search);      var searchLength = searchString.length;      var position = arguments.length &gt; 1 ? arguments[1] : undefined;      // `ToInteger`      var pos = position ? Number(position) : 0;      if (pos != pos) { // better `isNaN`        pos = 0;      }      var start = Math.min(Math.max(pos, 0), stringLength);      // Avoid the `indexOf` call if no match is possible      if (searchLength + start &gt; stringLength) {        return false;      }      var index = -1;      while (++index &lt; searchLength) {        if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {          return false;        }      }      return true;    };    if (defineProperty) {      defineProperty(String.prototype, &#39;startsWith&#39;, {        &#39;value&#39;: startsWith,        &#39;configurable&#39;: true,        &#39;writable&#39;: true      });    } else {      String.prototype.startsWith = startsWith;    }  }());}</code></pre><hr><h3 id="String-prototype-endsWith"><a href="#String-prototype-endsWith" class="headerlink" title="String.prototype.endsWith()"></a>String.prototype.endsWith()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.endsWith(searchString [, position]);</strong></p></blockquote><p><code>endsWith()</code> 方法用来判断当前字符串是否是以另外一个给定的子字符串结尾的。</p><p><code>searchString</code><br>要搜索的子字符串</p><p><code>position</code><br>在 str 中搜索 searchString 的结束位置，默认值为 <code>str.length</code>，也就是真正的字符串结尾处。</p><p><strong>Polyfill</strong></p><pre><code class="JavaScript">if (!String.prototype.endsWith) {    String.prototype.endsWith = function( searchString, position) {        if (position === undefined || position &gt; this.length) {            position = this.length;        }        return this.substring(position - searchString.length, position) === searchString;    };}</code></pre><hr><h3 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.slice(beginSlice[, endSlice])</strong></p></blockquote><p>slice() 方法提取一个字符串的一部分，并返回一新的字符串。</p><p><code>beginSlice</code><br>从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 <code>str.length + beginSlice</code>，如果是小数则保留整数部分，如果超出 <code>str.length</code> 则返回空字符串。</p><p><code>endSlice</code><br>在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，slice会一直提取到字符串末尾。如果该参数为负数，则被看作是 <code>str.length + endSlice</code>，如果是小数则保留整数部分，如果超出 <code>str.length</code> 则当做 <code>str.length</code>。</p><p><em>注意：提取的字符包括 <code>beginSlice</code> 位置的字符但是不包括 <code>endSlice</code> 位置的字符，如果 <code>endSlice &lt;= beginSlice</code> 则返回空字符串。</em></p><p>常用操作：配合 <code>Object.prototype.toString</code> 判断一个变量的类型</p><pre><code class="JavaScript">function type(v) {    return Object.prototype.toString.call(v).slice(8, -1);}</code></pre><!--```JavaScript// 这两个参数的内部机制可以用如下伪代码表示：String.prototype.slice = function(beginSlice, endSlice) {    let strLen = str.length;    endSlice = endSlice || strLen;    // 如果 endSlice <= beginSlice 则返回空字符串    if (endSlice <= beginSlice) {        return "";    }    // 如果 beginSlice 超出 str.length 则返回空字符串    if (beginSlice >= strLen) {        return "";    }    // 如果 endSlice 则当做 str.length    if (endSlice > strLen) {        endSlice = strLen;    }    // 如果参数值为负数则被当作 str.length + beginSlice    if(beginSlice < 0) {        beginSlice += strLen    }    if(endSlice < 0) {        endSlice += strLen    }    // 取整    beginSlice = beginSlice >>> 0;    endSlice = endSlice >>> 0;}```--><hr><h3 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.split([separator[, limit]])</strong></p></blockquote><p><code>split()</code> 方法使用指定的分隔符字符串将一个字符串分割成字符串数组。 </p><p><code>separator</code><br>表示每个拆分的位置。<code>separator</code> 可以是一个字符串或正则表达式。如果纯文本分隔符包含多个字符，则必须找到整个字符串来表示分割点。如果省略或在 <code>str</code> 中不出现分隔符，则返回的数组包含一个由整个字符串组成的元素。如果分隔符为空字符串，则将 <code>str</code> 原字符串中每个字符的数组形式返回。</p><p><code>limit</code><br>一个整数（如果是小数时，只保留整数部分，如果是负值则相当于无限制），限定返回的字符串数组的长度。当提供此参数时，<code>split</code> 方法会在指定分隔符的每次出现时分割该字符串，在数组长度达到限制长度时返回，后面如果还有剩下的字符串也会忽略掉。</p><p><em>Note: 如果 separator 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。</em></p><pre><code class="JavaScript">var str = &quot;Hello 1 word.&quot;;str.split(/(\d)/);   // [&quot;Hello &quot;, &quot;1&quot;, &quot; word.&quot;]str.split(/\d/);     // [&quot;Hello &quot;, &quot; word.&quot;]str.split(&quot;&quot;);       // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;1&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;d&quot;, &quot;.&quot;]str.split(&quot;&quot;, -1);   // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;, &quot; &quot;, &quot;1&quot;, &quot; &quot;, &quot;w&quot;, &quot;o&quot;, &quot;r&quot;, &quot;d&quot;, &quot;.&quot;]str.split(&quot;&quot; , 3);   // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;]str.split(&quot;&quot; , 3.5); // [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;]</code></pre><hr><h3 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.replace(regexp|substr, newSubStr|function)</strong></p></blockquote><p><code>replace()</code> 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。</p><p><em>Note: 原字符串不会改变。</em></p><p><code>regexp|substr</code><br>所匹配的内容会被第二个参数的返回值替换掉。</p><p><code>newSubStr</code><br>用于替换掉第一个参数在原字符串中的匹配部分的字符串。该字符串中可以内插一些特殊的变量名。</p><p><code>function</code><br>一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。</p><h4 id="使用-newSubStr-参数"><a href="#使用-newSubStr-参数" class="headerlink" title="使用 newSubStr 参数"></a>使用 <code>newSubStr</code> 参数</h4><table><thead><tr><th>变量名</th><th>值</th></tr></thead><tbody><tr><td>$$</td><td>插入一个 <code>&quot;$&quot;</code></td></tr><tr><td>$&amp;</td><td>插入匹配的子串</td></tr><tr><td>$`</td><td>插入当前匹配子串左边的内容</td></tr><tr><td>$’</td><td>插入当前匹配子串右边的内容</td></tr><tr><td>$n</td><td>第一个参数是 RegExp 对象，并且 n 是个小于100的非负整数，那么插入第 n 个括号匹配的字符串</td></tr></tbody></table><h4 id="指定一个函数作为参数"><a href="#指定一个函数作为参数" class="headerlink" title="指定一个函数作为参数"></a>指定一个函数作为参数</h4><p>你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意:  上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。</p><table><thead><tr><th>变量名</th><th>值</th></tr></thead><tbody><tr><td>match</td><td>匹配的子串。（对应于上述的$&amp;。）</td></tr><tr><td>p1,p2, …</td><td>如果 replace() 方法的第一个参数是一个 RegExp 对象，则代表第n个括号匹配的字符串。</td></tr><tr><td>offset</td><td>匹配到的子字符串在原字符串中的偏移量。</td></tr><tr><td>string</td><td>被匹配的原字符串。</td></tr></tbody></table><hr><h3 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.match(regexp)</strong></p></blockquote><p><code>match()</code> 方法检索匹配项，并以数组的方式返回结果。</p><p><code>regexp</code><br>一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp。如果不传参数，那么会返回一个包含空字符串的 Array ：[“”]（具体结果会因浏览器差异而不同，但是都返回数组且第一项为空字符串）。</p><pre><code class="JavaScript">var str1 = &quot;NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.&quot;,    str2 = &quot;My grandfather is 65 years old and My grandmother is 63 years old.&quot;,    str3 = &quot;The contract was declared null and void.&quot;;str1.match(&quot;number&quot;);   // &quot;number&quot; 是字符串。返回[&quot;number&quot;]str1.match(NaN);        // NaN的类型是number。返回[&quot;NaN&quot;]str1.match(Infinity);   // Infinity的类型是number。返回[&quot;Infinity&quot;]str1.match(+Infinity);  // 返回[&quot;Infinity&quot;]str1.match(-Infinity);  // 返回[&quot;-Infinity&quot;]str2.match(65);         // 返回[&quot;65&quot;]str2.match(+65);        // 有正号的number。返回[&quot;65&quot;]str3.match(null);       // 返回[&quot;null&quot;]</code></pre><hr><h3 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.search(regexp)</strong></p></blockquote><p><code>search()</code> 方法检索匹配项，并以返回首次匹配项的索引，如果没有返回 -1。</p><p><code>regexp</code><br>一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用 new RegExp(obj) 将其转换为一个 RegExp。</p><hr><h3 id="String-prototype-substr"><a href="#String-prototype-substr" class="headerlink" title="String.prototype.substr()"></a>String.prototype.substr()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.substr(start[, length])</strong></p></blockquote><p><code>substr()</code> 方法返回一个字符串中从指定位置开始到指定字符数的字符。</p><p><code>start</code><br>开始提取字符的位置。如果为负值，则被看作 <code>str.length + start</code>，如果为小数则保留整数部分。</p><p><code>length</code><br>提取的字符数，如果为小数则保留整数部分，如果 <code>start + length &gt; str.length</code> 则返回截取到字符串末尾，如果不传值默认截取到字符串末尾。</p><hr><h3 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h3><p><strong>语法</strong></p><blockquote><p><strong>str.substring(indexStart[, indexEnd])</strong></p></blockquote><p><code>substring()</code> 方法返回一个字符串在开始索引到结束索引之间的一个子字符串（包括开始索引位置的字符不包括结束索引位置的字符）。</p><p><code>indexStart</code><br>开始提取字符的位置。</p><p><code>indexEnd</code><br>结束提取字符的位置。</p><p>这两个参数有如下规则：</p><ul><li>如果 <code>indexStart == endStart</code> 返回空字符串</li><li>如果省略 <code>indexEnd</code>，返回子字符串直到字符串末尾</li><li>任一参数小于 <code>0</code> 或为 <code>NaN</code> 则当做 <code>0</code></li><li>任一参数大于 <code>str.length</code> 则当做 <code>str.length</code></li><li>如果 <code>indexStart &gt; indexEnd</code> 则两参数值互换</li></ul><hr><h3 id="String-prototype-repeat"><a href="#String-prototype-repeat" class="headerlink" title="String.prototype.repeat()"></a>String.prototype.repeat()</h3><p><strong>语法</strong></p><blockquote><p>str.repeat(count)</p></blockquote><p><code>repeat()</code> 方法返回一个新字符串，该字符串包含被连接在一起的指定次数的字符串。</p><p><code>count</code><br>介于0和正无穷大之间的整数 : [0, +∞) 。表示在新构造的字符串中重复了多少遍原字符串。</p><p><em>Note: <code>count</code> 不在指定范围内会报错，且如果构成的字符串超过了能够容纳的最大字符串长度也会报错，即内存溢出。</em></p><p><strong>Polyfill</strong></p><pre><code class="JavaScript">if (!String.prototype.repeat) {  String.prototype.repeat = function(count) {    &#39;use strict&#39;;    if (this == null) {      throw new TypeError(&#39;can\&#39;t convert &#39; + this + &#39; to object&#39;);    }    var str = &#39;&#39; + this;    count = +count;    if (count != count) {      count = 0;    }    if (count &lt; 0) {      throw new RangeError(&#39;repeat count must be non-negative&#39;);    }    if (count == Infinity) {      throw new RangeError(&#39;repeat count must be less than infinity&#39;);    }    count = Math.floor(count);    if (str.length == 0 || count == 0) {      return &#39;&#39;;    }    // 确保 count 是一个 31 位的整数。这样我们就可以使用如下优化的算法。    // 当前（2014年8月），绝大多数浏览器都不能支持 1 &lt;&lt; 28 长的字符串，所以：    if (str.length * count &gt;= 1 &lt;&lt; 28) {      throw new RangeError(&#39;repeat count must not overflow maximum string size&#39;);    }    var rpt = &#39;&#39;;    for (;;) {      if ((count &amp; 1) == 1) {        rpt += str;      }      count &gt;&gt;&gt;= 1;      if (count == 0) {        break;      }      str += str;    }    return rpt;  }}</code></pre><hr><h3 id="String-prototype-padStart"><a href="#String-prototype-padStart" class="headerlink" title="String.prototype.padStart()"></a>String.prototype.padStart()</h3><p><strong>语法</strong></p><blockquote><p>str.padStart(targetLength [, padString])</p></blockquote><p><code>padStart()</code> 方法用另一个字符串填充当前字符串(如果需要的话则重复填充)，返回填充后达到指定长度的字符串。从当前字符串的开始（左侧）开始填充。</p><p><code>targetLength</code><br>当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p><p><code>padString</code><br>填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。默认值为空格。</p><p><strong>Polyfill</strong></p><pre><code class="JavaScript">if (!String.prototype.padStart) {    String.prototype.padStart = function padStart(targetLength,padString) {        targetLength = targetLength &gt;&gt; 0; //floor if number or convert non-number to 0;        padString = String(padString || &#39; &#39;);        if (this.length &gt; targetLength) {            return String(this);        } else {            targetLength = targetLength - this.length;            if (targetLength &gt; padString.length) {                //append to original to ensure we are longer than needed                padString += padString.repeat(targetLength / padString.length);            }            return padString.slice(0, targetLength) + String(this);        }    };}</code></pre><hr><h3 id="String-prototype-padEnd"><a href="#String-prototype-padEnd" class="headerlink" title="String.prototype.padEnd()"></a>String.prototype.padEnd()</h3><p><strong>语法</strong></p><blockquote><p>str.padEnd(targetLength [, padString])</p></blockquote><p><code>padEnd()</code> 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。</p><p><code>targetLength</code><br>当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</p><p><code>padString</code><br>填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。默认值为空格。</p><p><strong>Polyfill</strong></p><pre><code class="JavaScript">if (!String.prototype.padEnd) {    String.prototype.padEnd = function padEnd(targetLength,padString) {        targetLength = targetLength &gt;&gt; 0; // floor if number or convert non-number to 0;        padString = String(padString || &#39; &#39;);        if (this.length &gt; targetLength) {            return String(this);        } else {            targetLength = targetLength-this.length;            if (targetLength &gt; padString.length) {                // append to original to ensure we are longer than needed                padString += padString.repeat(targetLength / padString.length);            }            return String(this) + padString.slice(0, targetLength);        }    };}</code></pre><p>一图胜千言<br><img src="/2018/07/12/JavaScript/String/String.png" alt="String 思维导图"></p><p>下面是 xmind 文件</p><p><a href="String.xmind">String.xmind</a></p>]]></content>
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>闭包与作用域</title>
      <link href="/2018/07/10/JavaScript/%E9%97%AD%E5%8C%85%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2018/07/10/JavaScript/%E9%97%AD%E5%8C%85%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>闭包与 JavaScript 变量的作用域息息相关。要理解闭包就要先理解 JavaScript 变量作用域。</p><p>变量的作用域有两种： 一种是全局的另一种是局部的。</p><pre><code class="JavaScript">var a = 1;var n = 9;function foo() {    var a = 0;    b = 2;    var c = 1;    console.log(a);    console.log(n);}foo(); // 0// 9console.log(a); // 1console.log(b); // 2  解释：如果局部变量没有用 var 命令声明，那么这个变量会被当做全局变量console.log(c); // ReferenceError: c is not defined</code></pre><p>如上函数变量 首先我们声明了一个全局的 <code>var a = 1</code> ，然后又声明了一个全局的函数 <code>foo</code>。</p><p><code>foo</code> 函数内部声明了函数内部的变量 <code>var a = 0</code>, 以及没有用 <code>var</code> 命令声明的变量 <code>b = 2</code>。</p><p>此时全局作用域即外部的 JavaScript 所执行的环境而局部作用域是 <code>foo</code> 函数内部。上面代码的执行结果应该很明显的表现了作用域的范围。</p><p>全局变量可以被局部作用域和全局作用域访问，然而局部变量却不可以被外部作用域访问。</p><h3 id="可以被欺骗的作用域"><a href="#可以被欺骗的作用域" class="headerlink" title="可以被欺骗的作用域"></a>可以被欺骗的作用域</h3><p>在 <strong>《你不懂 JS —— 作用域和闭包》</strong> 里看到了一段有趣的东西。我们可以欺骗词法作用域但是欺骗词法作用于会导致性能下降。因为引擎需要动态去改变某个变量的作用域环境。</p><h4 id="第一种是-eval"><a href="#第一种是-eval" class="headerlink" title="第一种是 eval"></a>第一种是 <em>eval</em></h4><pre><code class="JavaScript">var b = 2;function foo(str, a) {    eval(str);    console.log(a, b);}foo(&quot;var b = 3;&quot;, 1); // 1, 3</code></pre><p>上面的函数在 <code>eval</code> 执行完之后，引擎不会关心前面做了什么依然会乖乖的去寻找 <code>console.log</code> 所需要的两个变量 <code>a</code> 和 <code>b</code>， 首先 <code>a</code> 在函数的参数中找到了，其次找 <code>b</code> 由于执行了 <code>eval</code> 所有在函数内部存在了变量 <code>b = 3</code>。于是打印出 <code>1, 3</code></p><p><strong>Note: 当 <code>eval</code> 被用于 strict 模式的时候，<code>eval</code> 内部的声明不会改变包围它的作用域</strong></p><pre><code class="JavaScript">function foo(str) {    &quot;use strict&quot;;    eval(str);    console.log(a); // ReferenceError: a is not defined}foo(&quot;var a = 1;&quot;);</code></pre><h4 id="第二种是-with"><a href="#第二种是-with" class="headerlink" title="第二种是 with"></a>第二种是 <em>with</em></h4><p>好吧已经废除了不想多说 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with" target="_blank" rel="noopener">MDN with</a></p><h4 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h4><blockquote><p>JavaScript 引擎在编译阶段运行许多性能优化的工作。其中的一些优化原理都归结为实质在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明都在什么位置，这样在执行期间就可以少花些力气来解析标识符。</p><p>如果引擎在代码中发现一个 <code>eval</code> 或 <code>with</code>，它实质上就不得不假设自己知道所有的标识符的位置可能是无效的，因为他不可能在词法分析时就知道你会向 <code>eval</code> 或 <code>with</code> 传递什么样的代码来修改词法作用域。</p><p>换句话说，如果 <code>eval</code> 或 <code>with</code> 出现，那么引擎做的几乎所有优化都会变得没有意义。所以他简单地不做任何优化。代码会趋于运行的更慢（没有优化，代码就运行的更慢）</p><p>——《你不知道的 JavaScript —— 作用域与闭包》</p></blockquote><h2 id="什么是闭包-Closure"><a href="#什么是闭包-Closure" class="headerlink" title="什么是闭包 (Closure)"></a>什么是闭包 (Closure)</h2><p>闭包是函数和声明该函数的词法环境的组合</p><p>考虑如下函数</p><pre><code class="JavaScript">function makeAdder(x) {    return function(y) {        return x + y;    };}var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(2)); // 12</code></pre><p>上述函数中我们定义了一个 <code>makeAdder(x)</code> 函数，它接受一个参数 <code>x</code> 并返回一个新的函数。返回的函数接受一个参数 <code>y</code> 并返回 <code>x + y</code> 的值。</p><p><code>add5</code> 和 <code>add10</code> 都是闭包他们共享相同的函数定义，但是保存了不同的词法环境。在 <code>add5</code> 的环境中 <code>x</code> 是 5 而在 <code>add10</code> 中 <code>x</code> 是 10。</p><p>上述只是闭包的一种用来简略的介绍闭包的特性。</p><h3 id="实用的闭包"><a href="#实用的闭包" class="headerlink" title="实用的闭包"></a>实用的闭包</h3><p>闭包可以用来做很多事情，比如模拟面向对象的代码风格，提升代码执行效率。</p><p><strong>闭包的优点就是可以读取函数内部的变量，还可以让这些变量始终保持在内存当中。</strong></p><p>正好前些日子在看 <code>Sizzle</code> 的源码，其中也用到了很多闭包相关的东西。就用 <code>Sizzle</code> 源码作为例子吧。</p><h4 id="1-结果缓存"><a href="#1-结果缓存" class="headerlink" title="1. 结果缓存"></a>1. 结果缓存</h4><pre><code class="Javascript">/** * Create key-value caches of limited size * @returns {function(string, object)} Returns the Object data after storing it on itself with *    property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength) *    deleting the oldest entry */function createCache() {    var keys = [];    function cache( key, value ) {        // Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)        if ( keys.push( key + &quot; &quot; ) &gt; Expr.cacheLength ) {            // Only keep the most recent entries            delete cache[ keys.shift() ];        }        return (cache[ key + &quot; &quot; ] = value);    }    return cache;}var tokenCache = createCache();tokenCache( selector, groups );</code></pre><p><code>createCache()</code> 内部有一个 <code>keys</code> 数组用来维护需要缓存的关键字，缓存结果被当做属性存储在 <code>cache</code> 函数上，当 <code>keys</code> 的数量超出可缓存的数量就会删掉最开始缓存的内容。</p><p>这里 <code>keys</code> 只在函数执行时创建了，并且不会被回收掉。形成了一个闭包，外部通过 <code>cache</code> 函数依然可以访问到 <code>createCache</code> 内部的 <code>keys</code>。</p><h4 id="2-模拟私有方法"><a href="#2-模拟私有方法" class="headerlink" title="2. 模拟私有方法"></a>2. 模拟私有方法</h4><pre><code class="JavaScript">var Person = function() {    var name = &quot;noName&quot;;    return {        getName: function() {            return name;        },        setName: function(newName) {            name = newName        }    };};var person = Person();person.getName(); // noNameperson.setName(&quot;LiLei&quot;);person.getName(); // LiLei</code></pre><p><code>Person</code> 函数中的 <code>name</code> 作为一个私有变量只有调用 <code>getName</code> 方法才能访问的到，如果直接用 <code>person.name</code> 访问会得到 <code>undefined</code>。</p><h3 id="小心的使用闭包"><a href="#小心的使用闭包" class="headerlink" title="小心的使用闭包"></a>小心的使用闭包</h3><p>闭包的缺点也很明显：由于变量都被保存下来了，那么内存的消耗肯定相比于没有闭包要来的大。如果不小心使用很容易就造成内存泄漏。</p><h3 id="意料之外的闭包"><a href="#意料之外的闭包" class="headerlink" title="意料之外的闭包"></a>意料之外的闭包</h3><p>下面是 MDN 上关于闭包的一段代码，许多的面试题也喜欢用 for 循环 + setTimeout 来考察求职者对于闭包的理解。</p><pre><code class="JavaScript">function showHelp(help) {  document.getElementById(&#39;help&#39;).innerHTML = help;}function setupHelp() {  var helpText = [      {&#39;id&#39;: &#39;email&#39;, &#39;help&#39;: &#39;Your e-mail address&#39;},      {&#39;id&#39;: &#39;name&#39;, &#39;help&#39;: &#39;Your full name&#39;},      {&#39;id&#39;: &#39;age&#39;, &#39;help&#39;: &#39;Your age (you must be over 16)&#39;}    ];  for (var i = 0; i &lt; helpText.length; i++) {    var item = helpText[i];    document.getElementById(item.id).onfocus = function() {      showHelp(item.help);    }  }}setupHelp();</code></pre><p>毫无疑问上述代码不管哪个元素被 <code>focus</code> 都只会显示关于 age 的 help 信息，解法也大致那么几种。</p><ol><li>用 ES6 的 <code>let</code></li></ol><pre><code class="JavaScript">let item = helpText[i]</code></pre><ol start="2"><li>创建一个匿名闭包</li></ol><pre><code class="JavaScript">  for (var i = 0; i &lt; helpText.length; i++) {    (function(item) {        document.getElementById(item.id).onfocus = function() {            showHelp(item.help);        };    }(helpText[i]);  }</code></pre><ol start="3"><li>使用更多的闭包</li></ol><pre><code class="JavaScript">function showHelp(help) {  document.getElementById(&#39;help&#39;).innerHTML = help;}function makeHelpCallback(help) {  return function() {    showHelp(help);  };}function setupHelp() {  var helpText = [      {&#39;id&#39;: &#39;email&#39;, &#39;help&#39;: &#39;Your e-mail address&#39;},      {&#39;id&#39;: &#39;name&#39;, &#39;help&#39;: &#39;Your full name&#39;},      {&#39;id&#39;: &#39;age&#39;, &#39;help&#39;: &#39;Your age (you must be over 16)&#39;}    ];  for (var i = 0; i &lt; helpText.length; i++) {    var item = helpText[i];    document.getElementById(item.id).onfocus = makeHelpCallback(item.help);  }}setupHelp();</code></pre>]]></content>
      
      <categories>
          
          <category> 闭包与作用域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Wow BFC</title>
      <link href="/2018/07/01/%E5%89%8D%E7%AB%AF/Wow-BFC/"/>
      <url>/2018/07/01/%E5%89%8D%E7%AB%AF/Wow-BFC/</url>
      <content type="html"><![CDATA[<h1 id="哇哦，-BFC"><a href="#哇哦，-BFC" class="headerlink" title="哇哦， BFC"></a>哇哦， BFC</h1><p>经常用到和听到 BFC， 但是对于具体的 BFC 有哪些情况可以触发了解的还不是很全面，今天整理下对于 BFC 的理解。</p><h2 id="What’s-BFC"><a href="#What’s-BFC" class="headerlink" title="What’s BFC"></a>What’s BFC</h2><p>BFC (Block Formatting Context) 即块级格式化上下文。相似的还有 IFC (Inline), FFC (Flex), GFC (Grid)。</p><h3 id="BFC-布局规则"><a href="#BFC-布局规则" class="headerlink" title="BFC 布局规则"></a>BFC 布局规则</h3><ol><li>内部的盒子会在垂直方向一个接一个的放置。</li><li>盒子的垂直方向距离由 <code>margin</code> 决定。属于 <code>同一个 BFC</code> 的两个相邻盒子的 <code>margin</code> 会重叠，值由两个 <code>margin</code> 的最大值决定。</li><li>每个元素的 <code>margin</code> 的左边，与包含块的 <code>border</code> 的左边相接触（由左向右的布局，否则相反）</li><li>BFC 的区域不会与 float 盒子重叠。 </li><li>BFC 是页面上的隔离的独立容器，容器内的子元素不会影响到外面的元素。</li><li>计算 BFC 的高度时，浮动元素也参与计算</li></ol><h2 id="哪些元素会生成-BFC"><a href="#哪些元素会生成-BFC" class="headerlink" title="哪些元素会生成 BFC"></a>哪些元素会生成 BFC</h2><ul><li>根元素</li><li>float 属性不为 none</li><li>position 属性不为relative和static。</li><li>display 属性为 inline-block, table-cell, table-caption, flex, inline-flex 中的任何一个</li><li>overflow 不为 visible</li></ul><h2 id="BFC-的作用和原理"><a href="#BFC-的作用和原理" class="headerlink" title="BFC 的作用和原理"></a>BFC 的作用和原理</h2><h3 id="1-自适应两栏布局"><a href="#1-自适应两栏布局" class="headerlink" title="1. 自适应两栏布局"></a>1. 自适应两栏布局</h3><pre><code class="HTML">&lt;style&gt;    .demo1 {        position: relative;        width: 300px;        border: 1px solid #000;    }    .demo1 .aside {        float: left;        width: 100px;        height: 150px;        background: #f66;    }    .demo1 .main {        height: 200px;        overflow: hidden;        background: #fcc;    }&lt;/style&gt;&lt;div class=&quot;demo1&quot;&gt;    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>页面如下：</p><div><style>.demo1 {width: 300px; position: relative;border: 1px solid #000;}.demo1 .aside {width: 100px; height: 150px; float: left; background: #f66;}.demo1 .main {height: 200px;background: #fcc;overflow: hidden;}</style><div class="demo1"><div class="aside"></div><div class="main"></div></div></div><p>这里应用了 BFC 布局规则的第三条和第四条。</p><h3 id="2-清除内部浮动"><a href="#2-清除内部浮动" class="headerlink" title="2. 清除内部浮动"></a>2. 清除内部浮动</h3><pre><code class="HTML">&lt;style&gt;    .father {        width: 300px;        overflow: hidden;        border: 5px solid #fcc;    }    .child {        float: left;        width:100px;        height: 100px;        border: 5px solid #f66;    }&lt;/style&gt;&lt;div class=&quot;father&quot;&gt;    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><p>页面如下：</p><div><style>.father {overflow: hidden;border: 5px solid #fcc;width: 300px;}.child {border: 5px solid #f66;width:100px;height: 100px;float: left;}</style><div class="father"><div class="child"></div><div class="child"></div></div></div><p>这里应用了 BFC 布局规则的第六条。</p><h3 id="3-防止垂直-margin-重叠"><a href="#3-防止垂直-margin-重叠" class="headerlink" title="3. 防止垂直 margin 重叠"></a>3. 防止垂直 margin 重叠</h3><pre><code class="HTML">&lt;style&gt;    .demo3{        border: 1px solid #000;    }    .demo3 .wrap {        overflow: hidden;    }    .demo3 p {        margin: 100px;        line-height: 100px;        text-align:center;        color: #f55;        background: #fcc;    }&lt;/style&gt;&lt;div class=&quot;demo3&quot;&gt;    &lt;p&gt;Haha&lt;/p&gt;    &lt;div class=&quot;wrap&quot;&gt;        &lt;p&gt;Hehe&lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>页面如下:</p><div><style>.demo3{border: 1px solid #000;}.wrap {overflow: hidden;}#post-content .demo3 p {margin: 100px;line-height: 100px;text-align:center;color: #f55;background: #fcc;}</style><div class="demo3"><p>Haha</p><div class="wrap"><p>Hehe</p></div></div><p>这里应用了 BFC 布局规则的第二条。</p><hr><h2 id="What’s-IFC"><a href="#What’s-IFC" class="headerlink" title="What’s IFC"></a>What’s IFC</h2><p>IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)<br>IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。 同个 IFC 下的多个 line box 高度会不同。 IFC 中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。</p><p>那么IFC一般有什么用呢？</p><p>水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。<br>垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p><h2 id="What’s-GFC"><a href="#What’s-GFC" class="headerlink" title="What’s GFC"></a>What’s GFC</h2><p>GFC 当为一个元素设置 <code>display: grid</code> 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。 </p><p>那么 GFC 有什么用呢，和 table 又有什么区别呢？</p><p>首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。</p><h2 id="What’s-FFC"><a href="#What’s-FFC" class="headerlink" title="What’s FFC"></a>What’s FFC</h2><p>Flex Box 由伸缩容器和伸缩项目组成。通过设置元素的 <code>display: flex</code> 或 <code>inline-flex</code> 可以得到一个伸缩容器。</p><p>设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。</p><p>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。</p><hr><p>参考文章：<a href="http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html" target="_blank" rel="noopener">前端精选文摘：BFC 神奇背后的原理</a></p></div>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
          <category> BFC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React diff 算法</title>
      <link href="/2018/06/21/%E7%AE%97%E6%B3%95/React-diff-%E7%AE%97%E6%B3%95/"/>
      <url>/2018/06/21/%E7%AE%97%E6%B3%95/React-diff-%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="React-diff-算法浅析"><a href="#React-diff-算法浅析" class="headerlink" title="React diff 算法浅析"></a>React diff 算法浅析</h1><p>之前在<a href="https://hongxuwei.github.io/2018/05/22/%E5%89%8D%E7%AB%AF/React-1/">学习 <em>React</em> </a>的时候了解到 React 的 diff 算法可以帮助我们实现最小化的 DOM 操作。</p><p>今天我们来看看 React 的 diff 算法的处理方式。</p><h2 id="传统的-diff-算法"><a href="#传统的-diff-算法" class="headerlink" title="传统的 diff 算法"></a>传统的 diff 算法</h2><p>传统的 diff 算法通过循环递归对节点一次对比，效率很低，复杂度达到 O(n<sup>3</sup>), 其中 n 是树中节点的总数。这意味着如果要展示 1000 个节点，那么就要计算上十亿次。而真实的页面中节点的数量是不可知的。所以如果使用传统的 diff 算法代价太高了。</p><h2 id="React-的-diff-算法。"><a href="#React-的-diff-算法。" class="headerlink" title="React 的 diff 算法。"></a>React 的 diff 算法。</h2><p>传统 diff 算法的复杂度为 O(n<sup>3</sup>)，而 React 通过对于前端页面结构的理解，定制了特殊的策略，将复杂度转化成 O(n)。</p><h3 id="diff-策略"><a href="#diff-策略" class="headerlink" title="diff 策略"></a>diff 策略</h3><p>Facebook 的工程师基于现实中前端开发的经验制定了以下3条策略</p><ol><li>同级比较</li><li>同组件比较</li><li>子元素比较</li></ol><h4 id="1-同级比较"><a href="#1-同级比较" class="headerlink" title="1. 同级比较"></a>1. 同级比较</h4><p>对于两个 DOM tree 只比较同一层次的节点，忽略 DOM 中节点跨层级的移动操作。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p><p class="center"><img src="/2018/06/21/算法/React-diff-算法/levelByLevel.png" alt="同级比较"></p><p><em>Note: 保证稳定的 DOM 结构有利于提升性能，尽量不去修改标签类型。</em></p><h4 id="2-同组件比较"><a href="#2-同组件比较" class="headerlink" title="2. 同组件比较"></a>2. 同组件比较</h4><p>diff 算法当遇到组件变化时，不会比较两个组件的不同，因为这种比较几乎没有意义。</p><p class="center"><img src="/2018/06/21/算法/React-diff-算法/componentDiff.png" alt="同组件比较"></p><p><em>Note: 对于同一类型组件合理使用 <code>shouldComponentUpdate()</code>，应该避免结构相同类型不同的组件。</em></p><h4 id="3-子元素比较"><a href="#3-子元素比较" class="headerlink" title="3. 子元素比较"></a>3. 子元素比较</h4><p>当节点处于同一层级时，React diff 提供了三种节点操作，分别是 <code>INSERT_MARKUP</code>、<code>MOVE_EXISTING</code>、<code>REMOVE_NODE</code>。</p><ul><li><code>INSERT_MARKUP</code>，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。</li><li><code>MOVE_EXISTING</code>，在老集合有新 component 类型，且 element 是可更新的类型就需要做移动操作，可以复用以前的 DOM 节点。</li><li><code>REMOVE_NODE</code>，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。</li></ul><p>通常情况下 diff 在比较集合 <code>[A, B, C, D]</code> 和 <code>[D, A, B,C]</code> 时，会按位置逐个对比，发现每个位置的元素都有更新，就把旧集合全部移除替换成新的集合。这种比较是不合理的，合理的方式是复用 <code>A</code>，<code>B</code>，<code>C</code> 而将末尾的 <code>D</code> 移动到集合最前面。</p><p>React对这一现象做出了一个高效的策略：允许开发者对同一层级的同组子节点添加唯一key值进行区分。</p><p class="center"><img src="/2018/06/21/算法/React-diff-算法/elementDiff.png" alt="子元素比较"></p><p><em>Note: 在开发过程中，同层级的节点添加唯一key值可以极大提升性能，尽量减少将最后一个节点移动到列表首部的操作，当节点达到一定的数量以后或者操作过于频繁，在一定程度上会影响React的渲染性能。</em></p><p><strong>React 通过上面3种策略将原本 O(n<sup>3</sup>) 的算法复杂度降低到 O(n)</strong></p><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>把事件绑到 DOM 节点很慢，消耗内存。而 React 采用更好的技术称之为“事件代理”。React 走的更远，采用 W3C 兼容的事件系统。这意味着 IE8 的事件操作 Bugs 已经成为过去。所有的事件在不同浏览器中是一致的。<br>React 并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的 Listener，然后通过事件的 target 找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React 都会触发对应的事件处理函数。</p><h3 id="渲染（批量处理）"><a href="#渲染（批量处理）" class="headerlink" title="渲染（批量处理）"></a>渲染（批量处理）</h3><p>当在组件中调用了 <code>setState</code>, React 讲吧这个组件标记为 dirty，在时间循环结束后，React 会找到所有被标记的组件并统一渲染他们。而不是每次调用 <code>setState</code> 都去重新渲染。</p><p class="center"><img src="/2018/06/21/算法/React-diff-算法/dirty.png" alt="批量渲染"></p><h4 id="子树渲染"><a href="#子树渲染" class="headerlink" title="子树渲染"></a>子树渲染</h4><p>当 <code>setState</code> 调用时，组件会重新 build 其子虚拟 DOM。如果你在根节点上调用 <code>setState</code>，那么整个应用都会重新渲染，所有的组件，即使它没有改变也会调用它的 render 方法。这听起来很低效，但实际中，它工作很好应为我们没有操作实际的 DOM。<br>首先，我们谈论的是显示用户界面。应为屏幕空间是有限的，通常我们只会同时显示几百到上千个 elements。Javascript 有足够快的业务逻辑管理整个界面。<br>另一个很重要的是，当你写 React 代码时，不要一出现变化就在根节点上调用 <code>setState</code> 方法。你应该在接收变化事件的组件或其上面的组件上调用 <code>setState</code>，你应该极少的在上层中调。这意味着变化只会在用户交互的地方。</p><p class="center"><img src="/2018/06/21/算法/React-diff-算法/rerender.png" alt="子树渲染"></p><h4 id="有选择的渲染"><a href="#有选择的渲染" class="headerlink" title="有选择的渲染"></a>有选择的渲染</h4><p>我们可以通过下面的方法选择子树是否渲染：</p><pre><code class="JavaScript">boolean shouldComponentUpdate(object nextProps, object nextState)</code></pre><p>通过判断先前组件和下一个组件的属性/状态，你能够告诉 React 这个组件是否需要重新渲染。当合适的处理这将会显著提高性能。<br>为了使用它，你必须能比较对象的差异，这里就牵扯到一些问题，如是否应该深度比较，如果深度比较，我么是否应该固定数据的结构，或是做深度拷贝。<br>而且你应该记住，这个函数总会被调用，所以你要确保自己写的函数的调用时间要比默认的启发式比较的时间少。</p><p class="center"><img src="/2018/06/21/算法/React-diff-算法/shouldUpdate.png" alt="有选择的渲染"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过diff策略，将算法从O(n^3)简化为O(n)</li><li>分层求异，对tree diff进行优化</li><li>分组件求异，相同类生成相似树形结构、不同类生成不同树形结构，对component diff进行优化</li><li>设置key，对element diff进行优化</li><li>尽量保持稳定的DOM结构、避免将最后一个节点移动到列表首部、避免节点数量过大或更新过于频繁</li></ol>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Q&amp;A </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode1</title>
      <link href="/2018/06/19/%E7%AE%97%E6%B3%95/LeetCode1/"/>
      <url>/2018/06/19/%E7%AE%97%E6%B3%95/LeetCode1/</url>
      <content type="html"><![CDATA[<h1 id="LeetCode-算法题（第一弹）"><a href="#LeetCode-算法题（第一弹）" class="headerlink" title="LeetCode 算法题（第一弹）"></a>LeetCode 算法题（第一弹）</h1><p>之前小伙伴面试遇过这个<a href="https://hongxuwei.github.io/2018/06/12/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/">算法题</a>。 让我想到了一句话</p><blockquote><p>前端程序员，首先也要是一个程序员。</p></blockquote><p>一直以来都在看一些工作当中要用到的知识，反而忽视了程序员应该具备的一些基本素质。由于是非科班出身，基础反而薄弱，之前有看编译原理，但是虐的我好难啊，等我有所理解再来开新坑。</p><p>我自己面试的时候也会有遇到算法题，但是一般想出的都是常规的暴力解法，优化的解法一时也想不出，编程就像是做数学应用题一样，要多练才有思路，所以打算每天做一点点算法题。</p><h2 id="1两数之和"><a href="#1两数之和" class="headerlink" title="#1两数之和"></a>#1两数之和</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p><p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p><p><strong>示例：</strong></p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p></blockquote><h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><p>暴力法很简单。遍历每个元素 <code>x</code>，查找是否存在一个值与 <code>target - x</code> 相等的目标元素。</p><p><em>Note: 但是这里有一个坑就是当输入是 <code>nums = [3, 4, 5, 4], target = 8</code> 的时候要注意 <code>x</code> 和 <code>target - x</code> 的值都是 <code>4</code>，输出要过滤掉第二次查找到的是 <code>x</code> 本身。</em></p><pre><code class="JavaScript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function(nums, target) {    const len = nums.length;    for (let i = 0 ; i &lt; len; i++) {        let index = nums.indexOf(target - nums[i]);        if(index &gt; -1 &amp;&amp; index !== i) {            return [i, index];        }    }};</code></pre><h3 id="解法二：-哈希表法"><a href="#解法二：-哈希表法" class="headerlink" title="解法二： 哈希表法"></a>解法二： 哈希表法</h3><p>从哈希表中查找到一个元素的查找时间可以近似为 <code>O(1)</code><sup><a href="#qa1">[1]</a></sup>。哈希表它支持以近似恒定的时间进行快速查找。用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 <code>O(n)</code>。但只要仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 <code>O(1)</code>。所以可以以空间换取时间的方式优化运行时间。</p><p>用哈希表保存数组中的目标元素和索引，如果存在目标元素，找到他的索引就可以了。当然说的这么玄乎，哈希表其实就是JavaScript中对象的存储方式。所以JS的实现就比较简单啦。</p><pre><code class="JavaScript">/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function(nums, target) {    let hash = {};    let num, pair;    const len = nums.length;    for(let i = 0; i &lt; len; i++) {        num = nums[i];        pair = target - num;        if ( hash.hasOwnProperty(pair) ) {            return [hash[pair], i];        }        hash[num] = i;    }};</code></pre><h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="#2 两数相加"></a>#2 两数相加</h2><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>示例：</strong></p><blockquote><p><strong>输入：</strong>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br><strong>输出：</strong>7 -&gt; 0 -&gt; 8<br><strong>原因：</strong>342 + 465 = 807</p></blockquote><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>同时遍历两条链表，相同权重的每一位相加，超过9就添加进位，遍历下一个节点时将进位加入下一位。</p><p>这题的解法我目前也就只想到这点。要注意因为节点长度不同可能会导致遍历时需要判断是否某条链表已经结束，如果结束那这条链表的这一位需要置0。</p><pre><code class="JavaScript">/** * Definition for singly-linked list. * function ListNode(val) { *     this.val = val; *     this.next = null; * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var addTwoNumbers = function(l1, l2) {    let carry = 0;    let result;    let list;    while (l1 || l2) {        const val1 = l1 ? l1.val : 0;        const val2 = l2 ? l2.val : 0;        l1 = l1 &amp;&amp; l1.next;        l2 = l2 &amp;&amp; l2.next;        const val = val1 + val2 + carry;        carry = val &gt; 9 ? 1 : 0;        const node = new ListNode(val % 10);        if (list) {            list.next = node;        }        list = node;        result = result || list;    }    if (carry) {        list.next = {            val: 1,            next: null,        };    }    return result;};</code></pre><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="#3 无重复字符的最长子串"></a>#3 无重复字符的最长子串</h2><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p><p><strong>示例：</strong></p><blockquote><p>给定 <code>&quot;abcabcbb&quot;</code> ，没有重复字符的最长子串是 <code>&quot;abc&quot;</code> ，那么长度就是3。<br>给定 <code>&quot;bbbbb&quot;</code> ，最长的子串就是 <code>&quot;b&quot;</code> ，长度是1。<br>给定 <code>&quot;pwwkew&quot;</code> ，最长子串是 <code>&quot;wke&quot;</code> ，长度是3。请注意答案必须是一个子串，<code>&quot;pwke&quot;</code> 是 子序列  而不是子串。</p></blockquote><h3 id="解法一：暴力解法"><a href="#解法一：暴力解法" class="headerlink" title="解法一：暴力解法"></a>解法一：暴力解法</h3><p>我的思路是，从某一位 <code>start</code> 开始遍历这个字符串，之后再遍历 <code>start</code> 之后的字符串，找到第一次重复的位置，此次循环结束。</p><p>也就是找到这个字符串的所有不重复子字符串。</p><p>比如 <code>aabca</code>， 循环依次找到 <code>a</code> <code>abc</code> <code>bca</code> <code>ca</code> <code>a</code>。</p><p>这里我第一个循环并不是到字符串的最后，而是到总字符串长度减去目前已知的最大字符串长度。这样可以减少一些多余的查询。（但是依然很慢哈哈哈）</p><p>循环 <code>aabca</code> 只会执行两次 当找到 <code>abc</code> 后， <code>ret = 3</code>，后续的查找是无意义的，所以停止并返回值。</p><pre><code class="JavaScript">/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function(s) {    let cache = [];    const len = s.length;    var ret = 0;    for(let start = 0; start &lt; len - ret; start++) {        for(let j = start; j &lt; len; j++) {            if(cache.indexOf(s[j]) &gt; -1) {                break;            }            cache.push(s[j]);        }        ret = ret &gt; cache.length ? ret : cache.length;        cache = [];    }    return ret;};</code></pre><h3 id="解法二：滑动窗口法"><a href="#解法二：滑动窗口法" class="headerlink" title="解法二：滑动窗口法"></a>解法二：滑动窗口法</h3><p>这种解法就比较有意思了。</p><p>思路就是：定义一个窗口，设定窗口的起始位置。向后查找字符，如果遇到重复值窗口位置挪动到重复值第一次出现的位置的后面，这样窗口中的字符串就又是不重复的了，记录窗口的最大宽度，遍历完所有字符后返回最大窗口宽度。</p><p class="center"><img src="/2018/06/19/算法/LeetCode1/SlidingWindow.PNG" alt="SlideWindow"></p><p class="center">滑动窗口法</p><pre><code class="JavaScript">/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function(s) {    if (!s.length) return 0;    const len = s.length;    let max = flag = 0, hash = {};    for(let i = 0; i &lt; len; i++) {        if(hash[s[i]] !== undefined) {            flag = Math.max(hash[s[i]], flag);        }        hash[s[i]] = i + 1;        max = Math.max(i - flag + 1, max);    }    return max;};//--------------------------------------------------------/** * @param {string} s * @return {number} */var lengthOfLongestSubstring = function(s) {    if (!s.length) return 0;    const len = s.length;    let max = 1, flag = 0;    for(let i = 0; i &lt; len; i++) {        let index = s.indexOf(s[i], flag)         if (index !== -1 &amp;&amp; index &lt; i) flag = index + 1;        max = Math.max(max, i - flag + 1)    }    return max};</code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p id="qa1">1. 为什么说从哈希表中查找到一个元素的查找时间可以近似为 <code>O(1)</code></p><h2 id="原题地址"><a href="#原题地址" class="headerlink" title="原题地址"></a>原题地址</h2><p><a href="https://leetcode-cn.com/problems/two-sum/description/" target="_blank" rel="noopener">#1 两数之和</a><br><a href="https://leetcode-cn.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">#2 两数相加</a><br><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">#3 无重复字符的最长子串</a></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全排列问题</title>
      <link href="/2018/06/12/%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/12/%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h1 id="字符串的全排列问题"><a href="#字符串的全排列问题" class="headerlink" title="字符串的全排列问题"></a>字符串的全排列问题</h1><p>昨天<a href="https://github.com/MiaoQ" target="_blank" rel="noopener">小伙伴</a>面试遇到了这样一题。</p><p>要求给出一个函数，输入是一个字符串比如 <code>&quot;abc&quot;</code> 要求输出这个字符串中所有字符的所有不重复的排列组合。也就是<code>&quot;abc&quot; &quot;bac&quot; &quot;bca&quot; &quot;acb&quot; &quot;cab&quot; &quot;cba&quot;</code>;</p><p>当然看到算法题对于我来说就是崩溃的。因为想不到啊！</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>当然 Google 了一番之后，看到别人的解释之后才想通了怎么去实现。</p><ol><li>将字符串的第一个字符提出来</li></ol><p>比如 <code>abcd</code> 就取出第一个字符 <code>a</code></p><ol start="2"><li>将第一个字符一次插入剩余字符之中</li></ol><p><code>_b_c_d_</code> 就像是填空题，每次把 <code>a</code> 填入前面的横线中</p><ol start="3"><li>对于 <code>bcd</code> 递归执行该方法，得到 <code>bcd</code> 的全排列，重复前面两步。</li></ol><p><em>这里简化了很多，我的理解是将 <code>a</code> 看做一个整体， <code>bcd</code> 看做一个整体， 而 <code>bcd</code> 在递归中又是相当于第一次调用的该函数的 <code>abcd</code>， 取第一个字符 <code>b</code> 再对 <code>cd</code> 做全排列…依次进行下去。</em></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>感觉解释的还是不清楚，可能是自己没有完全理解吧。</p><p>不多哔哔，上代码。</p><pre><code class="JavaScript">function permutation(str) {    var len = str.length;    var result = [];    if (len === 1) {        // 如果长度为 1 直接返回该字符串        return [str];    } else {        // 每次对去除第一个字符后的字符串做全排列        var prePermuation = permutation(str.slice(1));        var preLength = prePermuation.length;        // 第一个字符，即要插入队内的字符        var curChar = str[0];        // 循环将第一个字符插入全排列好的字符数组中        for (let i = 0; i &lt; preLength; i++) {            var curStr = prePermuation[i];            // 循环将第一个字符插入字符串中                        for (let j = 0; j &lt; prePermuation[0].length + 1; j++) {                var tmp = curStr.substr(0, j) + curChar + curStr.slice(j);                result.push(tmp);            }        }   }    // 数组去重，方法很多，只是 ES6 的写法行数少 :) 这不重要啦。    return [...new Set(result)];}</code></pre><p>以后要多积累算法题，算法题一是靠智商，二是靠积累。我这种笨脑袋只好看看大牛的解法，然后去理解咯。</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串全排列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDB start</title>
      <link href="/2018/06/07/%E5%89%8D%E7%AB%AF/MongoDB-start/"/>
      <url>/2018/06/07/%E5%89%8D%E7%AB%AF/MongoDB-start/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在公司搞了个<a href="https://github.com/hongxuWei/let-s-talk" target="_blank" rel="noopener">聊天室</a>，用来和我家<a href="https://github.com/MiaoQ" target="_blank" rel="noopener">小可爱</a>说悄悄话❤。因为公司的 Skype 等会被监控啦。</p><p>初期版本特别简陋，用户信息是存放在一个服务端的 js 里， login 的时候，哈哈哈哈，去读取 js 里的变量，我都被我机智到了。</p><p>现在想加上数据库用户信息，聊天记录也要存放在数据库里。之前有弄过一段时间的 <code>MongoDB</code> 所以第一时间想到就是用它啦。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>公司电脑是 Win10 的，先去官网下载对应的安装文件 <a href="https://www.mongodb.com/download-center?jmp=nav#community" target="_blank" rel="noopener">MongoDB Window 下载地址</a></p><p>这种安装也不要什么说明啦，只是如果想要修改安装包的默认位置的话需要在  <code>Choose Setup Type</code> 这一步选择 <strong>Custom</strong>。之后就和安装普通的 Windows 软件一样。</p><p>这里我安装到了 D: 盘，安装完成后目录结构如下图</p><p class="center"><img src="/2018/06/07/前端/MongoDB-start/files.png" alt="files"></p><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p><strong>1. 配置环境变量</strong></p><p>为了下面敲命令方便这里把 MongoDB 的 <code>bin</code> 文件夹放入到 Windows 系统环境变量 <code>Path</code> 中。在我的安装目录中就是下面这样。</p><p class="center"><img src="/2018/06/07/前端/MongoDB-start/path.png" alt="path"></p><p><strong>2. 创建数据库存放地址</strong></p><p>我是把数据库的内容放在 D 盘的 data 文件夹下</p><pre><code class="shell">d:mkdir data\dbmkdir data\log</code></pre><p><strong>3. 创建配置文件</strong></p><p>创建配置文件，该文件必须设置 <code>systemLog.path</code></p><p>配置文件在 <code>D:\mongodb\mongod.cfg</code></p><p>内容如下</p><pre><code class="cfg">systemLog:    destination: file    path: d:\data\log\mongod.logstorage:    dbPath: d:\data\db</code></pre><p><strong>4. 安装 MongoDB 服务</strong></p><pre><code class="shell"># 管理员模式运行# --serviceName 是注册 windows 服务名称mongod --config &quot;D:\mongodb\mongod.cfg&quot; --install --serviceName &quot;MongoDB&quot;</code></pre><p>启动 MongoDB 服务</p><pre><code class="shell">net start MongoDB</code></pre><p>关闭 MongoDB 服务</p><pre><code class="shell">net stop MongoDB</code></pre><p>至此 MongoDB 的基本安装和配置已经完成。</p><p>命令行执行</p><pre><code class="shell">mongo</code></pre><p>就可以连接数据库了</p>]]></content>
      
      <categories>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Why is the DOM slow?</title>
      <link href="/2018/05/29/%E5%89%8D%E7%AB%AF/Why-is-the-DOM-slow/"/>
      <url>/2018/05/29/%E5%89%8D%E7%AB%AF/Why-is-the-DOM-slow/</url>
      <content type="html"><![CDATA[<h1 id="为什么大家都说-DOM-操作很慢"><a href="#为什么大家都说-DOM-操作很慢" class="headerlink" title="为什么大家都说 DOM 操作很慢"></a>为什么大家都说 DOM 操作很慢</h1><p>之前在<a href="https://hongxuwei.github.io/2018/05/22/%E5%89%8D%E7%AB%AF/React-1/">学习 <em>React</em> </a>的时候看到 <em>React</em> 的优势的时候就说， <em>React</em> 的 diff 算法，会“最小化”处理 DOM。因为操作 DOM 的开销太大了。频繁操作 DOM 会有性能问题。</p><p>那么今天就来了解下。为什么操作 DOM 会很慢。</p><h2 id="什么是-DOM-Document-Object-Model"><a href="#什么是-DOM-Document-Object-Model" class="headerlink" title="什么是 DOM (Document Object Model)"></a>什么是 DOM (Document Object Model)</h2><p>DOM 是一个独立于语言的，使用 <em>XML</em> 和 HTML 文档操作的接口。在浏览器中主要与 HTML 文档打交道。 DOM APIs 主要用于访问这些文档中的数据。</p><p>DOM 是个 API 浏览器通常要求 DOM 实现和 JavaScript 实现保持相互独立。例如 Chrome 中 使用 WebKit 的 WebCore 库渲染页面，但是具有一个分离的 JavaScript 引擎 V8</p><blockquote><p>Inherently Slow<br>这对性能意味着，两个独立的部分以功能接口连接就会带来性能损耗。一个恒形象的比喻是把 DOM 看成一个岛屿，把 JavaScript 看成另一个岛屿，两者之间以一座收费桥连接。每次 JavaScript 需要访问 DOM 时，需要过桥，交一次“过桥费”。 DOM 操作越多，费用越高。一般建议是尽量减少过桥次数。—— 《高性能 JavaScript》</p></blockquote><p><em>Note: 目前大多数的浏览器对此做的优化已经足够多，访问 DOM 的最主要的开销也不再次，而是每次 DOM 操作的“后遗症”——浏览器的重排（reflow） 和 重绘（repaint）</em></p><h2 id="DOM-访问和修改"><a href="#DOM-访问和修改" class="headerlink" title="DOM 访问和修改"></a>DOM 访问和修改</h2><p>访问一个 DOM 元素的代价就是交一次“过桥费”。修改元素的代价可能更多，因为它经常导致浏览器重新计算页面结构变化。</p><p>访问或修改元素最差的情况是使用循环去做，特别是是 HTML 集合中使用。比较下面两个例子。</p><pre><code class="JavaScript">function innerHTMLLoop() {    for(var count = 0; count &lt; 1000; count++) {        /* 在循环中访问 DOM 和修改 DOM。操作了 1000 次           每次先获得 DOM innerHTML 中的内容，然后去更新它。*/        document.getElementById().innerHTML += &quot;a&quot;;    }}</code></pre><pre><code class="JavaScript">function innerHTMLLoop() {    var content = &quot;&quot;;    for(var count = 0; count &lt; 1000; count++) {        content += &quot;a&quot;;  // 循环保存变量，然后一次性写入。    }    // 只访问和修改了一次 DOM    document.getElementById().innerHTML += content;}</code></pre><p>在所有浏览器中，第二张方法的运行速度都比一次快得多。</p><h2 id="HTML-集合"><a href="#HTML-集合" class="headerlink" title="HTML 集合"></a>HTML 集合</h2><p>HTML 集合是用于存放 DOM 节点引用的类数组对象。下列函数返回值就是：</p><ul><li>document.getElementsByName()</li><li>document.getElementsByClassName()</li><li>document.getElementsByTagName()</li></ul><p>下列属性也是</p><ul><li>document.images</li><li>doucment.links</li><li>document.forms</li><li>document.forms[0].elements</li><li>document.anchors</li></ul><p>HTML 集合实际上是在查询文档，当更新信息时，每次都会重复执行查询操作。</p><p>来看看下面的代码有什么问题吧。</p><pre><code class="JavaScript">var divs = document.getElementsByTagName(&#39;div&#39;);for (var i = 0; i &lt; divs.length; i++) {    document.body.appendChild(document.createElement(&#39;div&#39;));}</code></pre><p>循环中的判断条件是 <code>divs</code> 的长度，但是每次循环的时候会自动添加一个 <code>div元素</code> 到 body 中，所以每次查询 <code>length</code> 都会改变，导致死循环。</p><p>而遍历数组明显会快于同样大小的 HTML 集合。所以需要多次用到同一个 HTML 集合的时候可以考虑将集合中的元素拷贝到一个数组中，然后去遍历那个数组。</p><h2 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h2><p>首先要了解浏览器如何展示一个网页的。</p><h3 id="浏览器的构成"><a href="#浏览器的构成" class="headerlink" title="浏览器的构成"></a>浏览器的构成</h3><p>浏览器的主要构成如下：</p><p class="center"><img src="/2018/05/29/前端/Why-is-the-DOM-slow/layers.png" alt="Layers"></p><p class="center">浏览器主要组件</p><p>包含了：</p><ul><li><strong>The user interface</strong>: 包含了地址栏，前进后退按钮…等等除了请求页面窗口之外的地方。</li><li><strong>The browser engine</strong>: 请求和操作渲染引擎的接口</li><li><strong>The rendering engine</strong>: 负责展现请求页面。例如请求内容是个 HTML 它负责解析 HTML 和 CSS 并且显示</li><li><strong>Networking</strong>: 完成网络调用。例如 HTTP 请求，它是平台无关的接口可以在不同平台下使用。</li><li><strong>UI backend</strong>: 绘制想多选框和窗口等基本组件，具有不特定于某个平台的通用接口，底层调用用户接口</li><li><strong>JavaScript interpreter</strong>: 解释执行 JS 代码</li><li><strong>Data storage</strong>: 属于持久层，浏览器需要在硬盘中保存像 cookies 的各种数据。</li></ul><h4 id="Rendering-engine-所做的工作"><a href="#Rendering-engine-所做的工作" class="headerlink" title="Rendering engine 所做的工作"></a>Rendering engine 所做的工作</h4><p>渲染引擎搜先通过网络获得所请求文档的内容，通常以 8K 分块的方式完成。</p><p>下面是渲染引擎在获取内容后的基本流程：</p><p class="center"><img src="/2018/05/29/前端/Why-is-the-DOM-slow/mainflow.png" alt="mainflow"></p><p class="center">解析 HTML 构建 DOM 树 → 构建渲染树 → 布局渲染树 → 绘制渲染树</p><p class="center">渲染引擎基本流程</p><p>获取内容后，浏览器开始解析 HTML 并将标签转化为 “Content tree(DOM tree)” 中的 DOM 节点。接着，他解析外部 CSS 文件以及 style 标签中的样式信息，这些样式信息和 HTML 中的可见性指令将用来构建 Render tree</p><p>Render tree 为每个需要显示的 DOM 树节点存放至少一个节点（隐藏 DOM 元素在渲染树中没有对应节点）。渲染树上的节点称为“框”或“盒”，符合 CSS 模型的定义，将元素看做一个具有填充、边距、边框和位置的盒。Render tree 由一些包含颜色和大小等属性的矩形组成，它们将按正确的顺序显示到屏幕上。</p><p>Render tree 构建好了之后，将会执行布局过程，它将确定每个节点在屏幕上的确切坐标。下一步就是绘制，遍历 Render tree 并使用 UI backend 绘制每个节点。</p><p>这个过程是逐步完成的，为了更好地用户体验，渲染引擎将会尽可能早的将内容呈现在屏幕上，不会等所有的 HTML 都解析完成之后再去构建和布局 Render tree。它是解析完一部分内容后就显示一部分内容，同时可能还在通过网络下载其余内容。</p><p class="center"><img src="/2018/05/29/前端/Why-is-the-DOM-slow/webkitflow.png" alt="Webkit flow"></p><p class="center">Webkit 渲染引擎主流程</p><p class="center"><img src="/2018/05/29/前端/Why-is-the-DOM-slow/geckoflow.jpg" alt="Gecko flow"></p><p class="center">Geoko 渲染引擎主流程</p><p>影响页面展示的因素有许多，比如 link 位置会影响首屏显示.这里只讨论 layout 相关内容。</p><p>paint 是一个耗时的过程，但是 layout 是一个更耗时的过程。</p><p>当 DOM 改变影响到元素的几何属性（宽和高）———— 例如改变了边框宽度或是在段落中添加文字，将发生一系列后续动作 ———— 浏览器需要重新计算元素的几何属性，而且其他元素的几何属性和位置也会因此改变受到影响。浏览器使渲染树上受到的影响的部分失效，然后重构渲染树。这个过程被称作重排（reflow）。重排完成时，浏览器会在一个重绘进程中重新绘制屏幕上受影响的部分。</p><p>不是所有的 DOM 改变都会影响几何属性。比如，改变一个元素的背景颜色不会影响它的宽度和高度。在这种情况下，只需要重绘，因为元素的布局没有改变。</p><p>重绘和重排是负担很重的操作，可能导致网页应用的用户界面是去响应。所以十分有必要尽可能减少此类事情的发生。</p><h4 id="浏览器何时重排"><a href="#浏览器何时重排" class="headerlink" title="浏览器何时重排"></a>浏览器何时重排</h4><p>想要最小化重排次数，要先了解什么情况下浏览器会进行重排。</p><ul><li><strong>Page renders initially</strong>: 页面初始渲染</li><li><strong>Visible DOM elements are added or removed</strong>: 可见元素的添加或删除</li><li><strong>Elements change position</strong>: 元素位置改变</li><li><strong>Elements change size (because of a change in margin, padding, border thickness, width, height, etc.)</strong>: 由于 margin, padding, border-width, width, height 等属性导致的元素大小改变</li><li><strong>Content is changed (text changes or an image is replaced with on of a different size)</strong>: 文本改变或图片被另一个不同尺寸的图片替换时导致的内容改变</li><li><strong>Browser window is resized</strong>: 浏览器窗口大小改变</li></ul><p>根据改变的性质，渲染树上或大或小的一部分需要重新计算，某些改变可能导致重排整个页面：例如滚动条出现时。</p><h4 id="查询并刷新导致渲染树改变"><a href="#查询并刷新导致渲染树改变" class="headerlink" title="查询并刷新导致渲染树改变"></a>查询并刷新导致渲染树改变</h4><p>因为计算量和每次重排有关，大多数浏览器通过队列化化修改和批量显示优化重排过程。然而，我们可能不经意之间强迫队列刷新并要求所有改变的部分立刻应用。当我们查询一些布局信息的时候会导致浏览器更新渲染树。</p><p>如下方法：</p><ul><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li><li>clientTop, clientLeft, clientWidth, clientHeight</li><li>getComputedStyle() ( currentStyle() in IE)</li></ul><p>等等这些布局信息由这些属性和方法返回最新的数据，所以浏览器不得不运行渲染队列中待改变的项目并重新排版以返回正确的值。</p><p><em>拓展： <a href="https://csstriggers.com/" target="_blank" rel="noopener">会导致重排和重绘的 CSS 属性</a></em></p><h4 id="如何优化？"><a href="#如何优化？" class="headerlink" title="如何优化？"></a>如何优化？</h4><p>下面的例子导致了三次重排</p><pre><code class="JavaScript">// Readvar h1 = element1.clientHeight;// Write (invalidates layout)element1.style.height = (h1 * 2) + &#39;px&#39;;// Read (triggers layout)var h2 = element2.clientHeight;// Write (invalidates layout)element2.style.height = (h2 * 2) + &#39;px&#39;;// Read (triggers layout)var h3 = element3.clientHeight;// Write (invalidates layout)element3.style.height = (h3 * 2) + &#39;px&#39;;  </code></pre><p><strong>批处理优化</strong></p><pre><code class="JavaScript">// Readvar h1 = element1.clientHeight;  var h2 = element2.clientHeight;  var h3 = element3.clientHeight;// Write (invalidates layout)element1.style.height = (h1 * 2) + &#39;px&#39;;  element2.style.height = (h2 * 2) + &#39;px&#39;;  element3.style.height = (h3 * 2) + &#39;px&#39;; </code></pre><p><strong>另外当需要对 DOM 元素进行多次修改时，可以通过以下步骤减少重绘和重排的次数</strong></p><ol><li>从文档中摘除该元素</li><li>应用修改</li><li>将元素带回文档流中</li></ol><p>有三种基本方法可以将 DOM 从文档中摘除</p><ul><li>隐藏元素，进行修改然后再显示它</li><li>使用一个文档片段在已存 DOM 之外创建一个子树，然后将它拷贝到文档中（document.createDocumentFragment()）</li><li>将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素</li></ul><p><strong>将元素提出动画流</strong></p><p>显示和隐藏部分页面构成展开/折叠动画是一种常见的交互模式。它通常包括区域扩大的几何动画，将页面其他部分推向下方。</p><p>重排版有时只影响渲染树的一小部分，但也可以影响很大的一部分，甚至整个渲染树。浏览器需要重排<br>版的部分越小，应用程序的响应速度就越快。所以当一个页面顶部的动画推移了差不多整个页面时，将引<br>发巨大的重排版动作，使用户感到动画卡顿。渲染树的大多数节点需要被重新计算，它变得更糟糕。</p><p><strong>IE and :hover IE 和:hover</strong></p><p>自从版本 IE7 之后，可以在任何元素（严格模式）上使用 :hover 这个 CSS 伪选择器。然而，如果大量的元素使用了 :hover 那么会降低反应速度。此问题在 IE8 中更显著。</p><p><em>拓展：<a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener">How browsers work</a></em></p>]]></content>
      
      <categories>
          
          <category> Q&amp;A </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Q&amp;A </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 1</title>
      <link href="/2018/05/22/%E5%89%8D%E7%AB%AF/React-1/"/>
      <url>/2018/05/22/%E5%89%8D%E7%AB%AF/React-1/</url>
      <content type="html"><![CDATA[<h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>React是Facrbook内部的一个JavaScript类库，已于1年开源，可用于创建Web用户交互界面。它引入了一种新的方式来处理浏览器DOM。那些需要手动更新DOM、费力地记录每一个状态的日子一去不复返了——这种老舅的方式既不具备扩展性，又很难加入新的功能，就算可以，也是有着冒着很大的风险。React使用很新颖的方式解决了这些问题。你只需要声明地定义各个时间点的用户界面，而无序关系在数据变化时，需要更新哪一部分DOM。在任何时间点，React都能以最小的DOM修改来更新整个应用程序。</p><p>React引入了一些激动人心的新概念，向现有的一些最佳实践发起了挑战。学习这些概念，将帮助你理解它们的优势，创建具备高扩展性的单页面应用（SPA）。React把主要的注意力放在了应用的“视图”部分，没有限定与服务端交互和代码组织的方式。</p><h2 id="Why-React"><a href="#Why-React" class="headerlink" title="Why React?"></a>Why React?</h2><p>为什么要使用 React ? 老夫就是 jQuery 一梭子去撸不可以么？</p><p>😢还真不方便。产品经理说，这里需要给我改个东西。吭哧吭哧用 jQuery 写了半天，然后产品经理说，客户又改需求了！这种事情当然在实际开发中经常遇到，怎么办？难道真的像下面这样？</p><p class="center"><img src="/2018/05/22/前端/React-1/pm&amp;rd.png" alt="PM &amp; RD"></p><p>当然是用我们的技术去应对这种情况的发生。让开发变得更简单更高效，后期维护方便。上午改需求下午出 Release 这才是积极的应对方式🌞。</p><p>那 <code>React</code> 有哪些优势呢？</p><h4 id="1-大名鼎鼎的-Virtual-DOM"><a href="#1-大名鼎鼎的-Virtual-DOM" class="headerlink" title="1. 大名鼎鼎的 Virtual DOM"></a>1. 大名鼎鼎的 Virtual DOM</h4><p>对浏览器中的 DOM 操作开销是特别大的<sup><a href="#qa1">[1]</a></sup>。正常情况下一个状态改变，我们只需要对网页中需要改变的 DOM 做一些操作。</p><p>然而平常开发过程中（我）几乎不考虑对 DOM 操作有什么大的开销。而 React 会帮助我们做这些事情，用 React 内部自己的 diff 算法<sup><a href="#qa2">[2]</a></sup>帮助我们最小化的操作 DOM。</p><h4 id="2-组件化"><a href="#2-组件化" class="headerlink" title="2. 组件化"></a>2. 组件化</h4><p>组件化开发的优点想来不用多说。</p><p>高复用，UI 与 业务低耦合。 <code>React</code> 通过将每个功能相对独立的模块定义成组件，通过组件的组合嵌套的方式构成大的组件，完成整体构筑。</p><p>就像是砌房子一样。窗户是窗户，门是门，墙是墙，三者独立也是一个完整的东西，三者组合起来构成房屋。（家徒四壁）</p><p><code>React</code> 的组件化使得开发变得更加方便，可维护，使得代码复用率更高。一切都是 component。</p><h4 id="3-数据绑定"><a href="#3-数据绑定" class="headerlink" title="3. 数据绑定"></a>3. 数据绑定</h4><p><code>React</code> 的数据绑定是单向的。数据和视图进行了绑定，当数据变化时，视图自动更新，不用再操作，提升开发效率。</p><h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><p><strong>好吧其实也没多少。甚至说只有一点就是组件化，解决业务中的痛点。</strong></p><h2 id="Hello-JSX"><a href="#Hello-JSX" class="headerlink" title="Hello JSX"></a>Hello JSX</h2><p><strong>JSX</strong> 语法，像是在 <code>JavaScript</code> 代码里直接写 <em>XML</em> 的语法，实质上这只是一个语法糖，每一个 <em>XML</em> 标签都会被 <strong>JSX</strong> 转换工具转换成纯 <code>JavaScript</code> 代码，React 官方推荐使用 <strong>JSX</strong> ， 当然你想直接使用纯 <code>JavaScript</code> 代码写也是可以的，只是使用 <strong>JSX</strong> ，组件的结构和组件之间的关系看上去更加清晰。</p><pre><code class="JavaScript">//使用JSXReact.render(    &lt;div&gt;        &lt;div&gt;            &lt;div&gt;content&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;,    document.getElementById(&#39;example&#39;));//不使用JSXReact.render(    React.createElement(&#39;div&#39;, null,        React.createElement(&#39;div&#39;, null,            React.createElement(&#39;div&#39;, null, &#39;content&#39;)        )    ),    document.getElementById(&#39;example&#39;));</code></pre><p>其实我们在 <strong>JSX</strong> 里写一个 <em>XML</em> 标签，就是在调用 <code>React.createElement</code> 这个方法，并返回一个 <code>ReactElement</code> 对象。</p><h3 id="JSX-中嵌入表达式"><a href="#JSX-中嵌入表达式" class="headerlink" title="JSX 中嵌入表达式"></a>JSX 中嵌入表达式</h3><p>可以用花括号把任意的 <code>JavaScript 表达式</code> 嵌入到 <strong>JSX</strong> 。</p><pre><code class="JavaScript">function formatName(user) {    return user.firstName + &#39; &#39; + user.lastName;}const user = {    firstName: &#39;Harper&#39;,    lastName: &#39;Perez&#39;};const ele = (    &lt;h1&gt; Hello, {formatName(user)}!&lt;/h1&gt;);ReactDOM.render(    ele,    document.getElementById(&#39;root&#39;));</code></pre><h3 id="JSX-也是一个表达式"><a href="#JSX-也是一个表达式" class="headerlink" title="JSX 也是一个表达式"></a>JSX 也是一个表达式</h3><p>编译之后，<strong>JSX</strong> 表达式就变成了常规的 <code>JavaScript 对象</code></p><p>这意味着可以在 <code>if</code> 语句或是 <code>for</code> 循环中使用 <strong>JSX</strong> ，用它给变量赋值，当做参数接收，或则作为函数返回值。</p><pre><code class="JavaScript">function getGreeting(user) {    if (user) {        return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;    }    return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;}</code></pre><h3 id="用-JSX-指定属性值"><a href="#用-JSX-指定属性值" class="headerlink" title="用 JSX 指定属性值"></a>用 JSX 指定属性值</h3><p>可以使用双引号来指定字符串字面量作为属性值：</p><pre><code class="Javascript">const element = &lt;div tableIndex=&quot;0&quot;&gt;&lt;/div&gt;</code></pre><p>也可以使用花括号嵌入一个 JavaScript 表达式作为属性值：</p><pre><code class="JavaScript">const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;</code></pre><p><strong><em>JSX 使用时应该注意自闭合，class 关键字用 className 替代，单容器包裹等。</em></strong></p><h2 id="Components-amp-Props"><a href="#Components-amp-Props" class="headerlink" title="Components &amp; Props"></a>Components &amp; Props</h2><p>组件化将 UI 分为一个个独立可复用的小部件。</p><h3 id="函数式组件和类组件"><a href="#函数式组件和类组件" class="headerlink" title="函数式组件和类组件"></a>函数式组件和类组件</h3><p>定义组件的方式有两种，一个是写一个 JavaScript 函数或是用 ES6 来定义一个组件。</p><p>下面这两种组件在 <code>React</code> 看来是等价的。（注意下面组件的命名，首字母大写）</p><pre><code class="JavaScript">function Welcome(props) {    return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;}</code></pre><pre><code class="JavaScript">class Welcome extends React.Component {    constructor(props) {        super(props);    }    render() {        return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;    }}</code></pre><h3 id="渲染一个组件"><a href="#渲染一个组件" class="headerlink" title="渲染一个组件"></a>渲染一个组件</h3><p>React 元素可以是</p><pre><code class="JavaScript">const element = &lt;div /&gt;;</code></pre><p>也可以是用户自定义的组件</p><pre><code class="JavaScript">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;; //注意自闭合</code></pre><p>其中 JSX 的属性以一个单独对象 <code>props</code> 传递给对应的组件。</p><p><strong><em>Note: <code>props</code> 是只读的，React 组件都必须是纯函数，并且禁止修改自身 props。</em></strong></p><h2 id="状态和生命周期"><a href="#状态和生命周期" class="headerlink" title="状态和生命周期"></a>状态和生命周期</h2><p>有下面这样一个组件每秒会更新时间</p><pre><code class="JavaScript">class Clock extends React.Component {    constructor(props) {        super(props);        this.state = {            date: new Date(),            name: &quot;Sara&quot;        };    }    componentDidMount() {        this.timerID = setInterval(            () =&gt; this.tick(),            1000        );    }    componentWillUnmount() {        clearInterval(this.timerID);    }    tick() {        this.setState({date: new Date()})    }    render() {        return (            &lt;div&gt;                &lt;h1&gt;Hello, {this.state.name}.&lt;/h1&gt;                &lt;h2&gt;Time is {this.state.date.toLocalTimeString()}.&lt;/h2&gt;            &lt;/div&gt;        );    }}</code></pre><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>关于 state 有下面几点要注意</p><h4 id="1-不要直接修改-state-而是调用-setState-去更新"><a href="#1-不要直接修改-state-而是调用-setState-去更新" class="headerlink" title="1. 不要直接修改 state 而是调用 setState 去更新"></a>1. 不要直接修改 state 而是调用 setState 去更新</h4><pre><code class="JavaScript">this.state.name = &quot;Bob&quot;; // 错误，这样视图不会更新this.setState({name: &quot;Bob&quot;}); // OK</code></pre><h4 id="2-state-更新可能是异步的"><a href="#2-state-更新可能是异步的" class="headerlink" title="2. state 更新可能是异步的"></a>2. state 更新可能是异步的</h4><p>React 为了优化性能会将多个 <code>setState()</code> 调用合并。</p><p><code>this.props</code> 和 <code>this.state</code> 可能是异步更新，所以不能依赖他们的值去计算下一个 <strong>state</strong></p><pre><code class="JavaScript">this.setState({    counter: this.state.counter + this.props.increment // 可能会导致更新失败});/* 要解决这个问题，可以使用另一种 setState 的形式，它接受一个函数而不是一个对象。这个函数将接收前一个状态作为第一个参数，应用更新时的 prop 作为第二个参数 */this.setState((prevState, props) =&gt; ({    couter: prevSatete.counter + props.increment //OK}))</code></pre><h3 id="生命周期-lifecycle"><a href="#生命周期-lifecycle" class="headerlink" title="生命周期 lifecycle"></a>生命周期 lifecycle</h3><p>嗯哼，一图胜千言。</p><p class="center"><img src="/2018/05/22/前端/React-1/component-lifecycle.jpg" alt="生命周期"></p><p class="center">组件生命周期</p><h2 id="React-的数据流和组件间的通信"><a href="#React-的数据流和组件间的通信" class="headerlink" title="React 的数据流和组件间的通信"></a>React 的数据流和组件间的通信</h2><p>React 是单向数据流，数据主要从父节点传递到子节点 （<em>props</em>）</p><p>如果父级的某个 <em>props</em> 改变了，React 会重新渲染所有的子节点。</p><p><strong>props 和 state</strong></p><p>尽可能使用 <code>props</code> 当做数据源， <code>state</code> 用来存放状态值</p><p>即通常用 <code>props</code> 传递大量数据， <code>state</code> 用于存放组件内部一些简单的定义数据。</p><h3 id="那么组件间是怎么通信的呢？"><a href="#那么组件间是怎么通信的呢？" class="headerlink" title="那么组件间是怎么通信的呢？"></a>那么组件间是怎么通信的呢？</h3><p>组件间通信方式也就那么几种</p><ul><li>props</li><li>props 回调</li><li>context 对象</li><li>事件订阅</li></ul><h4 id="1-父子组件通信"><a href="#1-父子组件通信" class="headerlink" title="1. 父子组件通信"></a>1. 父子组件通信</h4><ul><li><strong>父组件更新状态 —— props ——&gt; 子组件更新</strong></li><li><strong>子组件更新  —— props 回调 ——&gt; 调用回调函数更新</strong></li></ul><h4 id="2-兄弟组件通信"><a href="#2-兄弟组件通信" class="headerlink" title="2. 兄弟组件通信"></a>2. 兄弟组件通信</h4><ul><li><strong>兄弟组件更新  —— props 回调 ——&gt; 调用回调函数更新</strong></li><li><strong>context方式更新</strong></li><li><strong>事件订阅</strong></li></ul><h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><p>React 处理事件与在 DOM 元素上处理事件的区别</p><ul><li>React 事件使用驼峰命名，而不是全小写。</li><li>通过 JSX 传递一个函数作为事件处理程序，而不是字符串。</li><li>阻止默认行为必须明确调用 <em>preventDeafult</em> 而不是 <em>return false</em>。</li></ul><pre><code class="JavaScript">class Toggle extends React.Component {    constructor(props) {    super(props);        this.state = {isToggleOn: true};        // 这个绑定是必要的，使`this`在回调中起作用        this.handleClick = this.handleClick.bind(this);    }    handleClick() {        this.setState(prevState =&gt; ({            isToggleOn: !prevState.isToggleOn        }));    }    render() {        return (            &lt;button onClick={this.handleClick}&gt;                {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;}            &lt;/button&gt;        );    }}ReactDOM.render(    &lt;Toggle /&gt;,    document.getElementById(&#39;root&#39;));</code></pre><p><strong>在 JSX 回调中必须注意 <em>this</em> 的指向问题(line 7)</strong></p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p><a href="https://reactjs.org/docs/conditional-rendering.html" target="_blank" rel="noopener">讲真没什么可写的，丢个链接吧。</a></p><h2 id="Lists-amp-Key"><a href="#Lists-amp-Key" class="headerlink" title="Lists &amp; Key"></a>Lists &amp; Key</h2><p>JavaScript 中转换列表</p><pre><code class="JavaScript">const number = [1, 2, 3, 4, 5];const double = number.map((number) =&gt; number * 2);</code></pre><p>在 React 中 转换数组为元素列表的方式和上述方法基本相同</p><h3 id="多组件渲染"><a href="#多组件渲染" class="headerlink" title="多组件渲染"></a>多组件渲染</h3><pre><code class="JavaScript">const number = [1, 2, 3, 4, 5];const listItems = number.map((number) =&gt; &lt;li&gt;{number}&lt;/li&gt;);ReactDOM.render(    &lt;ul&gt;{listItems}&lt;/ul&gt;,    document.getElementById(&#39;root&#39;))</code></pre><h3 id="基本列表组件"><a href="#基本列表组件" class="headerlink" title="基本列表组件"></a>基本列表组件</h3><p>通常情况下，我们会在一个组件中渲染列表，重构前面的例子到一个组件，它接受一个 numbers 数组，并输出一个元素的无序列表。</p><pre><code class="JavaScript">function NumberList(props) {  const numbers = props.numbers;  const listItems = numbers.map((number) =&gt;    &lt;li key={number.toString()}&gt;      {number}    &lt;/li&gt;  );  return (    &lt;ul&gt;{listItems}&lt;/ul&gt;  );}const number = [1, 2, 3, 4, 5];ReactDOM.render(    &lt;NumberList numbers={numbers} /&gt;,    document.getElementById(&#39;root&#39;))</code></pre><p><strong>注意第4行加上了 <em>key</em> 如果不加的话会有一个 Wraning: a key should be provided for list items</strong></p><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p>键(Keys) 帮助 React 标识哪个项被修改、添加或者移除了。数组中的每一个元素都应该有一个唯一不变的键(Keys)来标志</p><p>挑选 key 最好的方式是使用一个在它的同辈元素中不重复的标识字符串。多数情况你可以使用数据中的 id 作为 keys</p><p>当要渲染的列表项中没有稳定的 id 时，你可以使用数据项的索引值作为 key 的最后选择</p><p>而 keys 只在数组的上下文中存在意义</p><pre><code class="JavaScript">function ListItem(props) {    const value = props.value;    return (        // 错误！不需要在这里指定 key：        &lt;li key={value.toString()}&gt;        {value}        &lt;/li&gt;    );}function NumberList(props) {    const numbers = props.numbers;    const listItems = numbers.map((number) =&gt;    // 错误！key 应该在这里指定：        &lt;ListItem value={number} /&gt;    );    return (        &lt;ul&gt;        {listItems}        &lt;/ul&gt;    );}const numbers = [1, 2, 3, 4, 5];ReactDOM.render(    &lt;NumberList numbers={numbers} /&gt;,    document.getElementById(&#39;root&#39;));</code></pre><p><strong>键是React的一个内部映射，但其不会作为 <em>props</em> 传递给组件的内部。如果你需要在组件中使用相同的值，可以明确使用一个不同名字的 prop 传入。如：</strong></p><pre><code class="JavaScript">const content = posts.map((post) =&gt;    &lt;Post        key={post.id}        id={post.id}        title={post.title} /&gt;);</code></pre><h2 id="新开一栏-Q-amp-A"><a href="#新开一栏-Q-amp-A" class="headerlink" title="新开一栏 Q&amp;A"></a>新开一栏 Q&amp;A</h2><p>在写文章的时候还是会有一些地方不理解。比如</p><p id="qa1"><a href="https://hongxuwei.github.io/2018/05/29/%E5%89%8D%E7%AB%AF/Why-is-the-DOM-slow/">1. 为什么大家都说操作 DOM 很慢？你说慢就慢呀？慢在哪里？</a></p><p id="qa2"><a href="https://hongxuwei.github.io/2018/06/21/%E7%AE%97%E6%B3%95/React-diff-%E7%AE%97%E6%B3%95/">2. Em… <code>React</code> 的啥 diff 算法？简单点怎么实现？如何通过 diff 算法去优化我们的组件？</a></p><p>后续会开新坑把这些问题一一弄清楚。然后和这里链接起来。</p>]]></content>
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>水平垂直居中</title>
      <link href="/2018/05/10/%E5%89%8D%E7%AB%AF/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/2018/05/10/%E5%89%8D%E7%AB%AF/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      <content type="html"><![CDATA[<h1 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h1><p>今天看了水平垂直居中的各种实现方式。</p><p>我整理成了思维导图的形式。</p><p class="center"><img src="/2018/05/10/前端/水平垂直居中/水平垂直居中.png" alt="水平垂直居中"></p><p>下面是这是 xmind 文件</p><p><a href="水平垂直居中.xmind">水平垂直居中.xmind</a></p>]]></content>
      
      <categories>
          
          <category> CSS 居中 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 居中 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用排序算法</title>
      <link href="/2018/05/08/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2018/05/08/%E7%AE%97%E6%B3%95/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>对于JS实现排序的 <code>功能</code> 来说本不需要什么算法。就用自带的函数<br> <code>Array.sort()</code> 然后指定处理函数就好了。<br>如下：</p><pre><code class="JavaScript">arr.sort(function (i, j){    return i - j;});</code></pre><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code class="JavaScript">function bubbleSort(arr) {    var len = arr.length,    i, j, tmp;    for (i = 0; i &lt; len; i++) {        for (j = 0; j &lt; len - 1 - i; j++) {             if (arr[j+1] &lt; arr[j]) {                tmp = arr[j];                arr[j] = arr[j+1];                arr[j+1] = tmp;            }        }    }    return arr;}</code></pre><h2 id="进化版"><a href="#进化版" class="headerlink" title="进化版"></a>进化版</h2><pre><code class="JavaScript">function bubbleSort(arr) {    var i = arr.length - 1,    j, pos, tmp;    while (i &gt; 0) {        pos = 0;        for (j = 0; j &lt; i; j++) {            if (arr[j] &gt; arr[j+1]) {                pos = j;                tmp = arr[j + 1];                arr[j + 1] = arr[j];                arr[j] = tmp;            }        }    }    return arr;}</code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次循环找出当前最小的数字</p><pre><code class="JavaScript">function selectionSort(arr) {    var  len = arr.len,    i, j, minNumIndex;    for (i = 0 ; i &lt; len; i++) {        minNumIndex = i;        for ( j = i + 1; j &lt; len; j++) {            if (arr[j] &lt; arr[minNumIndex]) {                minNumIndex = j;            }        }        tmp = arr[j];        arr[i] = arr[minNumIndex];        arr[minNumIndex] = tmp;    }    return arr;}</code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><pre><code class="JavaScript">function insertionSort(arr) {    var len = arr.length,    i, j, key;    for (i = 1; i &lt; leng; i++) {        key = arr[i];        j = i - 1;        while (arr[j + 1] &gt; key) {            arr[j + 1] = arr[j];            j--;        }        arr[j + 1] = key;    }    return arr;}</code></pre><h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><pre><code class="JavaScript">function instertionSortDichotomy(arr) {    var len = arr.length,    i, j, tmp, low, high, mid;    for ( i = 1; i &lt; len; i++) {        tmp = arr[i];        low = 0;        high = i - 1;        while (low &lt;= high) {            mid = parseInt((low + high) / 2, 10);            if (tmp &lt; arr[mid]){                hight = mid - 1;            } else {                low = mid + 1;            }        }        for(j = i - 1; j &gt;= high + 1; j--) {            arr[j + 1] = arr[j];        }        arr[j + 1] = tmp;    }    return arr;}</code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>先将整个待排序记录序列分割成若干个子序列<br>在序列内分别进行直接插入排序，待整个序列基本有序时，再对全体记录进行一次直接插入排序。</p><pre><code class="JavaScript">function shellSort() {    var len = arr.length,    gap = parseInt(len / 2),    i, j, tmp,    while (gap &gt; 0) {        for (i = gap; i &lt; len; i++) {            tmp = arr[i];            j = i - gap;            while (j &gt;= 0 &amp;&amp; tmp &lt; arr[j]) {                arr[j + gap] = arr[j];                j = j - gap;            }            arr[j + gap] = tmp;        }        gap = parseInt(gap / 2);    }    return arr;}</code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><pre><code class="JavaScript">function mergeSort(arr) {    var len = arr.length,    middle, left, right;    if (len &lt; 2) {        return arr;    }    middle = Math.floor(len / 2);    left = arr.slice(0, middle);    right = arr.slice(middle);    return merge(mergeSort(left), mergeSort(right));}function merge(left, right) {    var result = [];    while(left.length &amp;&amp; right.length) {        if(left[0] &lt;= right[0]) {            result.push(left.shift());        } else {            result.push(right.shift());        }    }    while(left.length) {        result.push(left.shift());    }    while(right.length) {        result.push(reight.shift());    }    return result;}</code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><pre><code class="JavaScript">function quickSort(arr, left, right) {    var x, i, j, tmp;    if (left &lt; right) {        x = arr[right];        i = left - 1;        for (j = left; j &lt;= right; j++) {            if (arr[j] &lt;= x) {                i++                tmp = arr[i];                arr[i] = arr[j];                arr[j] = tmp;            }        }        quickSort(arr, left, i - 1);        quickSort(arr, i + 1, right);    }    return arr;}</code></pre><h2 id="形象版快速排序"><a href="#形象版快速排序" class="headerlink" title="形象版快速排序"></a>形象版快速排序</h2><pre><code class="JavaScript">function quickSort(arr) {    if(arr.length &lt;= 1) {        return arr;    }    var pivotIndex = Math.floor(arr.length / 2),    pivot = arr.splice(pivotIndex, 1)[0],    left = [],    right = [],    i;    for (i = 0; i &lt; arr.length; i++) {        if (arr[i] &lt; pivot) {            left.push(arr[i])        } else {            right.push(arr[i])        }    }    return quickSort(left).concat([pivot], quickSort(right));}</code></pre><p>疑惑？</p><p>为什么把 <code>arr.length</code> 改为 <code>var len = arr.length;</code> 然后用 <code>len</code> 统一替换就会出现溢出 <code>Maximum call stack size exceeded</code></p>]]></content>
      
      <categories>
          
          <category> JavaScript 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网页加载优化</title>
      <link href="/2018/05/04/%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2018/05/04/%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h1 id="网页加载速度优化"><a href="#网页加载速度优化" class="headerlink" title="网页加载速度优化"></a>网页加载速度优化</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近做项目的时候，原本打开比较快的网页由于 CUP 的性能问题导致一样的代码在另一块芯片上打开速度明显变慢。</p><p>这套代码是台湾的同事做的，由于某些原因做了一半转接到我们手上。原本 <code>Broadcom</code> 芯片的机器网页打开速度比较快，换到只有他 <code>1/4</code> 处理速度的 <code>Realtek</code> 芯片的机器上首屏加载白屏时间变得比较长，这才开始优化网页代码结构。</p><p>但是网页优化技巧是相同的。所以这里也把了解的一些网页优化的技巧做一个整理。</p><h2 id="雅虎网页优化守则"><a href="#雅虎网页优化守则" class="headerlink" title="雅虎网页优化守则"></a>雅虎网页优化守则</h2><h3 id="内容部分"><a href="#内容部分" class="headerlink" title="内容部分"></a>内容部分</h3><h4 id="1-尽量减少HTTP请求次数"><a href="#1-尽量减少HTTP请求次数" class="headerlink" title="1. 尽量减少HTTP请求次数"></a>1. 尽量减少HTTP请求次数</h4><p><code>HTTP</code> 请求的原理就不在这里展开细说，总之每一次的 <code>HTTP</code> 如果没有 <code>Connection: keep-alive</code> 的话，就是重新建立一次 <code>TCP</code>。这个开销是可以降低的。(使用 <code>Connection: keep-alive</code> 建立一次 <code>TCP</code> 连接之后一直使用该连接保持会话。直到连接关闭。)</p><p>网页的加载速度，大部分都是在下载或是等待下载页面上的不同组件：图片，样式，脚本等。减少这些组件的数量就能够减少页面 <code>HTTP</code> 数量。</p><p><strong>a. 合并文件</strong></p><p>将css，js文件等合并</p><p><strong>b. 使用CSS Sprite</strong></p><p>CSS Sprite 减少图片请求数量，多用于许多小而繁多的 icon 图片。将多个图片合并为同一个使用的时候用  <code>background-image</code> 和 <code>background-position</code> 来控制图片的显示。</p><p><strong>c. Base64 编码图片</strong></p><p>行内图片<code>Base64编码</code>用 img: src: url() 的方式把图片嵌入到页面中，这样会增加 css 的体积但是减少了 <code>HTTP</code> 请求的数量。使用 Base64 的返回只限一些体积较小的图片。如果体积较大转为 <code>Base64编码</code> 后的体积远远大于原图片体积。就会适得其反。所以一般来说转码后超过 1k（取决于你团队对于css/js 体积和对减少 HTTP 请求带来的效益的权衡）就不太适合 <code>Base64编码</code>。</p><h4 id="2-减少-DNS-查找"><a href="#2-减少-DNS-查找" class="headerlink" title="2. 减少 DNS 查找"></a>2. 减少 DNS 查找</h4><p>浏览器 DNS 的查找顺序是 浏览器缓存 → 系统缓存 → 路由器缓存 → ISP（互联网服务提供商）DNS缓存 → 根服务器 → 顶级域名服务器 → 主域名服务器 → 保存结果</p><p>具体解析过程可以后续再开一文。</p><p>减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。</p><h4 id="3-避免重定向"><a href="#3-避免重定向" class="headerlink" title="3. 避免重定向"></a>3. 避免重定向</h4><p>重定向用 301 和 302 状态码。<br>下面是 301 状态码的 HTTP 头:</p><pre><code>HTTP/1.1 301 Moved PermanentlyLocation: http://example.com/Content-Type: text/html</code></pre><p>浏览器会自动跳转到 Location 域指明的 URL。重定向需要的所有信息都在 HTTP 头部，而响应体一般是空的。其实额外的 HTTP 头比如 Expires 和 Cache-Control 也表示重定向。除此之外还有别的跳转方式，如：refresh 元标签和 javascript, 但如果必须要做重定向，最好用标准的 3xx HTTP 状态码。</p><p>重定向会降低用户体验，在用户和 HTML 文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法下载，直到浏览器得到 HTML 文档。</p><h4 id="4-让-Ajax-可以缓存"><a href="#4-让-Ajax-可以缓存" class="headerlink" title="4. 让 Ajax 可以缓存"></a>4. 让 Ajax 可以缓存</h4><p>确保Ajax请求具有长久的Expires头</p><h4 id="5-延迟加载组件"><a href="#5-延迟加载组件" class="headerlink" title="5. 延迟加载组件"></a>5. 延迟加载组件</h4><p>将首页渲染所必须的组件加载出来，不必须的组件在首页渲染完成后再加载。</p><h4 id="6-预加载组件"><a href="#6-预加载组件" class="headerlink" title="6. 预加载组件"></a>6. 预加载组件</h4><p>通过预加载组件，利用浏览器空闲时间来请求将来用户会用到的组件，当用户开始访问后续文档时，这些组件已经被缓存起来，所以在用户看来页面会加载得更快。</p><h4 id="7-减少-DOM-元素的数量"><a href="#7-减少-DOM-元素的数量" class="headerlink" title="7. 减少 DOM 元素的数量"></a>7. 减少 DOM 元素的数量</h4><p>一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。</p><h4 id="8-跨域分离组件"><a href="#8-跨域分离组件" class="headerlink" title="8. 跨域分离组件"></a>8. 跨域分离组件</h4><p>分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在 <a href="http://www.example.org" target="_blank" rel="noopener">www.example.org</a> ，而把静态组件分离到 static1.example.org。</p><h4 id="9-尽量少用-iframe"><a href="#9-尽量少用-iframe" class="headerlink" title="9. 尽量少用 iframe"></a>9. 尽量少用 iframe</h4><p>用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。</p><p><code>iframe</code> 的优点：</p><ul><li>引入缓慢的第三方内容，比如标志和广告</li><li>安全沙箱</li><li>并行下载脚本</li></ul><p><code>iframe</code>的缺点：</p><ul><li>代价高昂，即使是空白的iframe</li><li>阻塞页面加载</li><li>非语义</li></ul><h4 id="杜绝-404"><a href="#杜绝-404" class="headerlink" title="杜绝 404"></a>杜绝 404</h4><p>HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。</p><h3 id="CSS-部分"><a href="#CSS-部分" class="headerlink" title="CSS 部分"></a>CSS 部分</h3><p>我觉得这一 part 完全是为了填 IE 的坑。哈哈哈。</p><h4 id="11-避免使用-CSS-表达式（IE）"><a href="#11-避免使用-CSS-表达式（IE）" class="headerlink" title="11. 避免使用 CSS 表达式（IE）"></a>11. 避免使用 CSS 表达式（IE）</h4><p>用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：</p><pre><code class="css">background-color: expression( (new Date()).getHours()%2 ? &quot;#B8D4FF&quot; : &quot;#F08A00&quot; );</code></pre><p>（但是 CSS 新标准似乎打算为 CSS 提供比 <code>calc</code> 更强大的能力，期待(*❦ω❦)）</p><h4 id="12-选择-lt-link-gt-舍弃-import（IE）"><a href="#12-选择-lt-link-gt-舍弃-import（IE）" class="headerlink" title="12. 选择 &lt;link&gt; 舍弃 @import（IE）"></a>12. 选择 <code>&lt;link&gt;</code> 舍弃 <code>@import</code>（IE）</h4><p>为了实现逐步渲染，CSS应该放在顶部。在IE中用@import与在底部用 <code>&lt;link&gt;</code> 效果一样，所以最好不要用它。</p><h4 id="13-避免使用滤镜（IE）"><a href="#13-避免使用滤镜（IE）" class="headerlink" title="13. 避免使用滤镜（IE）"></a>13. 避免使用滤镜（IE）</h4><p>IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。</p><p>最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。</p><h4 id="14-把样式放在顶部"><a href="#14-把样式放在顶部" class="headerlink" title="14. 把样式放在顶部"></a>14. 把样式放在顶部</h4><p>把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。</p><p>关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。</p><h3 id="js-部分"><a href="#js-部分" class="headerlink" title="js 部分"></a>js 部分</h3><h4 id="15-去除重复脚本"><a href="#15-去除重复脚本" class="headerlink" title="15. 去除重复脚本"></a>15. 去除重复脚本</h4><p>页面含有重复的脚本文件会影响性能，IE会产生不必要的HTTP请求，在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。</p><h4 id="16-尽量减少-DOM-的访问"><a href="#16-尽量减少-DOM-的访问" class="headerlink" title="16. 尽量减少 DOM 的访问"></a>16. 尽量减少 DOM 的访问</h4><p>用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：</p><ul><li>缓存已访问过的元素的索引</li><li>先“离线”更新节点，再把它们添到DOM树上 （documentFragment）</li><li>避免用JavaScript修复布局问题</li></ul><h4 id="17-用智能的时间处理器"><a href="#17-用智能的时间处理器" class="headerlink" title="17. 用智能的时间处理器"></a>17. 用智能的时间处理器</h4><p>事件委托</p><h4 id="18-把脚本放在底部"><a href="#18-把脚本放在底部" class="headerlink" title="18. 把脚本放在底部"></a>18. 把脚本放在底部</h4><p>脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。</p><p>有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。</p><p>一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。</p><h4 id="19-把-js-和-CSS-放到外面"><a href="#19-把-js-和-CSS-放到外面" class="headerlink" title="19. 把 js 和 CSS 放到外面"></a>19. 把 js 和 CSS 放到外面</h4><p>用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。</p><h4 id="20-压缩-js-和-CSS"><a href="#20-压缩-js-和-CSS" class="headerlink" title="20. 压缩 js 和 CSS"></a>20. 压缩 js 和 CSS</h4><p>去除代码中不必要的字符减少文件体积，提升加载速度。 Yahoo 在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。</p><p>除了压缩外部脚本和样式，行内的 <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。</p><h3 id="图片部分"><a href="#图片部分" class="headerlink" title="图片部分"></a>图片部分</h3><h4 id="21-优化图片"><a href="#21-优化图片" class="headerlink" title="21. 优化图片"></a>21. 优化图片</h4><p>尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）</p><p>当然在 2018 年的今天，已经有了更多可以优化的策略，webp? svg? fonticon? … 等等</p><h4 id="22-优化-CSS-Sprite"><a href="#22-优化-CSS-Sprite" class="headerlink" title="22. 优化 CSS Sprite"></a>22. 优化 CSS Sprite</h4><ul><li>在Sprite图片中横向排列一般都比纵向排列的最终文件小</li><li>组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式</li><li>“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。</li></ul><h4 id="23-不要用HTML缩放图片"><a href="#23-不要用HTML缩放图片" class="headerlink" title="23. 不要用HTML缩放图片"></a>23. 不要用HTML缩放图片</h4><p>不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要</p><pre><code class="HTML">&lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;cat.jpg&quot; alt=&quot;Cat&quot; /&gt;</code></pre><p>那么图片本身（cat.jpg）应该是100x100px的，而不是去缩小500 x 500px的图片。</p><h4 id="24-用小的可缓存的-favicon-ico"><a href="#24-用小的可缓存的-favicon-ico" class="headerlink" title="24. 用小的可缓存的 favicon.ico"></a>24. 用小的可缓存的 favicon.ico</h4><p>favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。</p><p>所以为了缓解favicon.ico的缺点，应该确保：</p><ul><li>足够小，最好在1K以下</li><li>设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为比较安全的长度，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</li></ul><h3 id="cookie部分"><a href="#cookie部分" class="headerlink" title="cookie部分"></a>cookie部分</h3><h4 id="25-给-cookie-减肥"><a href="#25-给-cookie-减肥" class="headerlink" title="25. 给 cookie 减肥"></a>25. 给 cookie 减肥</h4><p>使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。</p><ul><li>清除不必要的cookie</li><li>保证cookie尽可能小，以最小化对用户响应时间的影响</li><li>注意给cookie设置合适的域级别，以免影响其它子域</li><li>设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间</li></ul><h4 id="26-把组件放在不含-cookie-的域下"><a href="#26-把组件放在不含-cookie-的域下" class="headerlink" title="26. 把组件放在不含 cookie 的域下"></a>26. 把组件放在不含 cookie 的域下</h4><p>当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。</p><p>　　如果域名是 <a href="http://www.example.org" target="_blank" rel="noopener">www.example.org</a> ，可以把静态组件部署到 static.example.org 。然而，如果已经在顶级域 example.org 或者 <a href="http://www.example.org" target="_blank" rel="noopener">www.example.org</a> 设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是 yimg.com ，YouTube是 ytimg.com ，Amazon是 images-amazon.com 等等。</p><p>　　把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用 example.org 还是 <a href="http://www.example.org" target="_blank" rel="noopener">www.example.org</a> 作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。</p><h3 id="移动端部分"><a href="#移动端部分" class="headerlink" title="移动端部分"></a>移动端部分</h3><h4 id="27-保证所有组件都小于25K"><a href="#27-保证所有组件都小于25K" class="headerlink" title="27. 保证所有组件都小于25K"></a>27. 保证所有组件都小于25K</h4><p>这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p><h4 id="28-把组件打包到一个复合文档里"><a href="#28-把组件打包到一个复合文档里" class="headerlink" title="28. 把组件打包到一个复合文档里"></a>28. 把组件打包到一个复合文档里</h4><p>把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。</p><h3 id="服务器部分"><a href="#服务器部分" class="headerlink" title="服务器部分"></a>服务器部分</h3><h4 id="29-Gzip组件"><a href="#29-Gzip组件" class="headerlink" title="29. Gzip组件"></a>29. Gzip组件</h4><p>gzip 可以大幅减少文本类的数据大小 html, css, js 等体积会大幅减少。</p><p>从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。</p><pre><code>Accept-Encoding: gzip, deflate</code></pre><p>如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。</p><pre><code>Content-Encoding: gzip</code></pre><h4 id="30-避免图片src属性为空"><a href="#30-避免图片src属性为空" class="headerlink" title="30. 避免图片src属性为空"></a>30. 避免图片src属性为空</h4><p>Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现：</p><pre><code class="HTML">&lt;img src=&quot;&quot;&gt;</code></pre><pre><code class="JavaScript">var img = new Image();img.src = &quot;&quot;;</code></pre><p>这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。</p><h4 id="31-配置-ETags"><a href="#31-配置-ETags" class="headerlink" title="31. 配置 ETags"></a>31. 配置 ETags</h4><p>实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag：</p><pre><code>HTTP/1.1 200 OKLast-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot;Content-Length: 12195</code></pre><p>然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。</p><pre><code>GET /i/yahoo.gif HTTP/1.1Host: us.yimg.comIf-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified</code></pre><h3 id="对-Ajax-使用-GET-请求"><a href="#对-Ajax-使用-GET-请求" class="headerlink" title="对 Ajax 使用 GET 请求"></a>对 Ajax 使用 GET 请求</h3><p>Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。</p><p>POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。</p><h4 id="33-尽早清空缓冲区"><a href="#33-尽早清空缓冲区" class="headerlink" title="33. 尽早清空缓冲区"></a>33. 尽早清空缓冲区</h4><p>当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，响应耗时主要在后台方面时，这么做会更有优势</p><p>较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。</p><h4 id="34-使用CDN（内容分发网络）"><a href="#34-使用CDN（内容分发网络）" class="headerlink" title="34. 使用CDN（内容分发网络）"></a>34. 使用CDN（内容分发网络）</h4><p>用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？</p><p>实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。</p><p>记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业届黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。</p><p>内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。</p><h4 id="35-添上Expires或者Cache-Control-HTTP头"><a href="#35-添上Expires或者Cache-Control-HTTP头" class="headerlink" title="35. 添上Expires或者Cache-Control HTTP头"></a>35. 添上Expires或者Cache-Control HTTP头</h4><ul><li>对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效</li><li>多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求</li></ul><p>浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。</p>]]></content>
      
      <categories>
          
          <category> 雅虎网页优化条例 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网页 </tag>
            
            <tag> 首屏加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Generator &amp; async (2)</title>
      <link href="/2018/04/25/JavaScript/Generator-async2/"/>
      <url>/2018/04/25/JavaScript/Generator-async2/</url>
      <content type="html"><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><h2 id="4-for…of-循环"><a href="#4-for…of-循环" class="headerlink" title="4. for…of 循环"></a>4. for…of 循环</h2><p><code>for...of</code> 循环可以自动遍历 Gnerator 函数生成的 <code>Iterator</code> 对象，而且这个时候不需要调用 <code>next</code> 方法。</p><pre><code class="JavaScript">function* foo() {    yield 1;    yield 2;    yield 3;    return 4}for(let value of foo()) {    console.log(value);}/* 1 2 3 */</code></pre><p>依次显示3个 <code>yield</code> 表达式的值。<br><strong>Note: 一旦 <code>Next</code> 方法返回的对象中 <code>done</code> 属性为 <code>true</code>， <code>for...of</code> 循环就会终止，且不包含该返回对象，所以上述代码 <code>return</code> 语句中返回的 <code>4</code> 不包含在 <code>for...of</code> 循环里</strong></p><pre><code class="JavaScript">// 循环打印斐波那契数列function* fibonacci() {    let [prev, curr] = [0, 1];    for(;;) {        [prev, curr] = [curr, prev + curr];        yield curr;    }}for (let n of fibonacci()) {    if (n &gt; 1000) break;    console.log(n);}</code></pre><p>除了 for…of 之外， 扩展运算符（…）、结构赋值和 <code>Array.from</code> 方法内部调用的都是遍历器接口，所以它们都可以将 Generator 函数返回的 Iterator 对象作为参数。</p><pre><code class="JavaScript">function* num() {    yield 1    yield 2    return 3}// 扩展运算符[...num()] //[1, 2]Array.from(num()) //[1, 2]let [x, y] = num();x // 1y // 2for (let n of num()) {    console.log(n)}// 1// 2</code></pre><h2 id="5-Generator-prototype-throw"><a href="#5-Generator-prototype-throw" class="headerlink" title="5. Generator.prototype.throw()"></a>5. Generator.prototype.throw()</h2><p>在函数体外抛出错误，然后在 Geneartor 函数体内部捕获。</p><p><strong>Note: <code>throw</code> 方法会默认执行一次 <code>next</code></strong></p><h2 id="6-Generator-prototype-return"><a href="#6-Generator-prototype-return" class="headerlink" title="6. Generator.prototype.return()"></a>6. Generator.prototype.return()</h2><p>可以返回给定的值，并终结遍历 Generator 函数。</p><p><strong>Note: 如果函数内部有 <code>try...finally</code> 代码块，那么 <code>return</code> 方法会推迟到 <code>finally</code> 代码块执行完再执行</strong></p><h2 id="7-next-throw-return-的共同点"><a href="#7-next-throw-return-的共同点" class="headerlink" title="7. next() throw() return() 的共同点"></a>7. next() throw() return() 的共同点</h2><p><code>next()</code> <code>throw()</code> <code>return()</code> 三个方法本质是同一件事，可以放在一起理解，它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 <code>yield</code> 表达式。</p><p><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值。</p><p><code>throw</code> 是将 <code>yield</code> 表达式替换成 <code>throw</code> 语句</p><p><code>return</code> 是将 <code>yield</code> 表达式替换成 <code>return</code> 语句</p><h2 id="8-yield-表达式"><a href="#8-yield-表达式" class="headerlink" title="8. yield* 表达式"></a>8. yield* 表达式</h2><p>如果在 Generator 函数内部抵用另外一个 Generator 函数，默认情况下是没有效果的。这时候就需要用到 <code>yield*</code> 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><p><strong>任何数据结构只要有 Iterator 接口，就可以被<code>yield*</code> 遍历。</strong></p>]]></content>
      
      <categories>
          
          <category> ES6 Generator async </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Generator </tag>
            
            <tag> async </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Generator &amp; async （1）</title>
      <link href="/2018/04/21/JavaScript/Generator-async/"/>
      <url>/2018/04/21/JavaScript/Generator-async/</url>
      <content type="html"><![CDATA[<h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p><code>Generator</code> 是 ES6 提出的一种异步解决方案。</p><p>形式上 Generator 函数和普通函数有两个不同点。</p><ul><li><code>function</code> 关键字和函数名之间有一个星号，如： <code>function* demo</code>;</li><li>内部函数使用 <code>yield</code> 表达式，定义不同的内部状态。</li></ul><pre><code class="JavaScript">function* demo(){    yield &#39;hi&#39;;    yield &#39;second&#39;;    return &#39;end&#39;;}var test = demo();test.next(); //{value: &#39;hi&#39;, done: false}test.next(); //{value: &#39;second&#39;, done: false}test.next(); //{value: &#39;end&#39;, done: true}test.next(); //{value: undefined, done: true}</code></pre><p>调用 <code>demo</code> 后函数并不会执行，返回的也不是函数运行的结果，而是一个指向内部状态的指针，只有当调用遍历器对象的 <code>next()</code> 方法，内部指针就从函数头或者上一次停下来的地方执行，知道遇到下一个 yield 表达式或者 return 语句为止。</p><h2 id="1-yield-表达式"><a href="#1-yield-表达式" class="headerlink" title="1. yield 表达式"></a>1. yield 表达式</h2><p>类似 Generator 函数的一个内部暂停标志。</p><p>Generator 函数就像一条马路，而 yield 是这条马路上的红绿灯路口，next 方法是站在每个路口指挥的交警。只有交警同意车辆通过后，才会执行相应的函数。</p><p>next 方法的运行逻辑有以下几点：</p><ul><li>遇到 <code>yield</code> 就暂停后面的操作，并将紧跟在 <code>yield</code> 后的表达式的值，作为返回对象的 <code>value</code> 属性值</li><li>下次调用 <code>next</code> 方法是，再继续向下执行， 直到遇到下一个 <code>yield</code> 表达式或者 <code>return</code> 语句</li><li>如果函数没有 <code>return</code> 语句，那么返回对象的 <code>value</code> 属性值为 <code>undefined</code></li></ul><p><code>yield</code> 和 <code>return</code> 的不同点在于，一个函数的 <code>return</code> 语句最多只能执行一次，而 <code>yield</code> 可以执行多次。 <code>yield</code> 会使函数暂停执行，下次执行的时候会从该位置继续向后执行，而 <code>return</code> 不具有记忆性。</p><p><strong>注意：Generator 函数可以不必使用 yield。但是如果使用 yield 就必须在 Generator 函数里面，否则会报错。<br><code>yield</code> 表达式如果用在另一个表达式之中，必须添加在圆括号里面。 <code>console.log(&#39;Hello&#39; + (yield));</code></strong></p><h2 id="2-Generator-与-Iterator"><a href="#2-Generator-与-Iterator" class="headerlink" title="2. Generator 与 Iterator"></a>2. Generator 与 Iterator</h2><p>任意一个对象的 <code>Symbol.iterator</code> 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p><p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有 <code>Symbol.iterator</code> 属性，执行后返回自身。</p><pre><code class="JavaScript">function* demo(){    // do some thing}var g = demo();g[Symbil.iterator] === g; // true</code></pre><h2 id="3-next-方法的参数"><a href="#3-next-方法的参数" class="headerlink" title="3. next 方法的参数"></a>3. next 方法的参数</h2><p><code>yield</code> 表达式本省没有返回值，或者说总是返回 <code>undefined</code>。 <code>next</code> 方法可以带一个参数，该参数就会被当做上一个 <code>yield</code> 表达式的返回值。</p><pre><code class="JavaScript">function* f(){    for( var i = 0; true; i++){        var reset = yield i;        if(reset) {            i = -1;        }    }}var g = f();g.next(); // {value: 0, done: false}g.next(); // {value: 1, done: false}g.next(true); // {value: 0, done: false}</code></pre>]]></content>
      
      <categories>
          
          <category> ES6 Generator async </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Generator </tag>
            
            <tag> async </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>想开个 ES6 的坑</title>
      <link href="/2018/04/20/JavaScript/%E6%83%B3%E5%BC%80%E4%B8%AA-ES6-%E7%9A%84%E5%9D%91/"/>
      <url>/2018/04/20/JavaScript/%E6%83%B3%E5%BC%80%E4%B8%AA-ES6-%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<h1 id="ES6-Promise"><a href="#ES6-Promise" class="headerlink" title="ES6 Promise"></a>ES6 Promise</h1><p><code>Promise</code> 是 ES6 的异步编程解决方案。</p><p>Promise 有 3 种状态 <code>pending</code> （正在进行）<code>fulfilled</code> (成功) <code>rejected</code> (失败)。 只有异步操作的结果可以决定状态。</p><p>其中 这3种状态的转换关系是 <code>pending</code> -&gt; <code>fulfilled</code>, <code>pending</code> -&gt; <code>rejected</code>. 而 fulfilled 和 rejected 这两种状态一旦形成就不可改变。</p><p>一图胜千言<br><img src="/2018/04/20/JavaScript/想开个-ES6-的坑/promise.png" alt="Promise图解"></p><h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1. 用法"></a>1. 用法</h2><p>Promise 对象是一个构造函数，用来生成 Promise 实例。</p><pre><code class="JavaScript">const promise = new Promise((resolve, reject)=&gt;{    /* do some thing */    if(/* promise success */) {        resolve(value);    } else {        reject(error)    }})</code></pre><p><code>resolve</code> 函数将 <code>Promise</code> 对象状态由 <code>pending</code> 变为 <code>fulfilled</code> 状态， 在异步操作成功时调用，并将异步操作的结果作为参数传递。</p><p><code>reject</code> 函数的作用是，将 <code>Promise</code>对象的状态从 <code>pending</code> 变为 <code>rejected</code> 状态，在异步操作失败时调用，并将异步操作报出的错误作为参数传递。</p><h2 id="2-Promise-prototype-then"><a href="#2-Promise-prototype-then" class="headerlink" title="2. Promise.prototype.then()"></a>2. Promise.prototype.then()</h2><p>Promise 实例生成之后就可以调用 then 方法分别指定 fulfilled 状态和 rejected 状态的回调函数。</p><pre><code class="JavaScript">promise.then((value)=&gt;{    /* do some thing when success */}, (error)=&gt;{    /* do some thing when failed */})</code></pre><p>如上所示，then 方法可以接受两个参数，分别对应的是 <code>fulfilled</code> 状态的回调函数和 <code>rejected</code> 状态的回调函数。其中 <code>rejected</code> 状态的回调函数是可选参数。</p><h2 id="3-Promise-prototype-catch"><a href="#3-Promise-prototype-catch" class="headerlink" title="3. Promise.prototype.catch()"></a>3. Promise.prototype.catch()</h2><p>相当于 <code>promise.then(null, rejection)</code> 用于指定异步操作失败时候的回调函数。</p><p><strong>注意：如果 Promise 的状态已经是fulfilled的话，再抛出错误则不会调用 rejection函数</strong></p><p><strong>Promise对象的错误具有“冒泡”性质，会一直向后传递，知道被捕获为止</strong></p><h2 id="4-Promise-prototype-finnaly"><a href="#4-Promise-prototype-finnaly" class="headerlink" title="4. Promise.prototype.finnaly()"></a>4. Promise.prototype.finnaly()</h2><p><code>finally</code> 方法用于不论 Promise 对象的状态如何，都会执行的操作。（ES2018)</p><h2 id="5-Promise-all"><a href="#5-Promise-all" class="headerlink" title="5. Promise.all()"></a>5. Promise.all()</h2><p>用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="JavaScript">const p = Promise([p1, p2, p3]);</code></pre><p>Promise.all 方法接受一个数组作为参数，数组内都是 Promise 实例。 如果不是就会调用 Promise.resolve 方法，将参数转为 Promise 实例。</p><p>（假设成功为true, 失败为false）<br><code>p = p1 &amp;&amp; p2 &amp;&amp; p3</code> 即 p1, p2, p3的状态都是 fulfilled 时 p 的状态才是 fulfilled。只要其中一个状态是 rejected, 那么 p 的状态就为 rejected。</p><h2 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6. Promise.race()"></a>6. Promise.race()</h2><p>Promise.race 方法同 Promise.all 类似。只不过正如方法名一样，竞争态的 Promise，一旦其中有任何一个 Promise 的状态确定了，无论是 fulfilled 还是 rejected Promise.race 的状态也就和其一样。</p><h2 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7. Promise.resolve()"></a>7. Promise.resolve()</h2><p>将现有对象转为 Promise 对象</p><ul><li>参数是 <code>Promise</code> 实例，该方法不做任何处理，直接返回该实例。</li><li>参数是一个 <code>thenable</code> 对象，该方法会将对象转为 Promise 对象，然后执行 thenable 对象的 then 方法。</li><li>参数不是具有 then 方法的对象或根本不是对象，该方法返回一个新的 Promise 对象，状态为 <code>fulfilled</code>。</li><li>没有参数，该方法返回一个新的 Promise 对象，状态为 <code>fulfilled</code>。</li></ul><h2 id="8-Promise-reject"><a href="#8-Promise-reject" class="headerlink" title="8. Promise.reject()"></a>8. Promise.reject()</h2><p>该方法会返回一个新的 Promise 实例，该实例的状态为 rejected。</p><p><strong>注意：该方法的参数，会作为reject的理由变成后续方法的参数。</strong></p><pre><code class="JavaScript">const thenable = {    then(resolve, reject) {        reject(&#39;error&#39;);    }}Promise.reject(thenable).catch(e=&gt;{    console.log(e === thenable)})// true</code></pre>]]></content>
      
      <categories>
          
          <category> JavaScript ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gitpage &amp; Hexo</title>
      <link href="/2018/04/18/%E5%89%8D%E7%AB%AF/Hexo-gitpage/"/>
      <url>/2018/04/18/%E5%89%8D%E7%AB%AF/Hexo-gitpage/</url>
      <content type="html"><![CDATA[<h1 id="Gitpage-配合-Hexo-搭建自己的博客"><a href="#Gitpage-配合-Hexo-搭建自己的博客" class="headerlink" title="Gitpage 配合 Hexo 搭建自己的博客"></a>Gitpage 配合 Hexo 搭建自己的博客</h1><p>之前面试感觉自己的技术沉淀还是不够。目前打算用博客记录自己的学习心得。之前一直是用云笔记记录。现在改用gitpage + hexo，一方面GitHub 的提交记录方便自己查看更新状态，能够对自己有个审视。另一方面，放在github上方便别人阅读查看和共享。</p><h2 id="1-用-GitHub-创建一个-Repository"><a href="#1-用-GitHub-创建一个-Repository" class="headerlink" title="1. 用 GitHub 创建一个 Repository."></a>1. 用 GitHub 创建一个 Repository.</h2><ul><li><p>登录 GitHub 主页。点击 New Repository</p></li><li><p>Repository name 名称填上 GitHub 的用户名 + github.io。 <code>例如： 我叫 hongxuWei, 那么我 GitHub 仓库的名称就填 hongxuWei.github.io</code></p></li><li><p>点击 Create repository</p></li></ul><p>如何查看是否创建成功呢？</p><p>在新建的仓库下创建一个 index.html 静态文件。以我自己为例，登录 <a href="https://hongxuwei.github.io">https://hongxuwei.github.io</a>  (协议类型https不要省略)<br>如果可以访问那么第一步就完成了。</p><h2 id="2-本地下载-hexo"><a href="#2-本地下载-hexo" class="headerlink" title="2. 本地下载 hexo"></a>2. 本地下载 hexo</h2><pre><code class="bash">npm install hexo-cli -ghexo init gitpage #这里 gitpage 仅仅指你博客的名称cd gitpagenpm installhexo g # markdown 文件生成为 html 文件hexo s # 开启本地预览 http://localhost:4000/</code></pre><p>这样我们就可以愉快的用 markdown 写博客啦。</p><h2 id="3-部署-hexo-到-gitpage"><a href="#3-部署-hexo-到-gitpage" class="headerlink" title="3. 部署 hexo 到 gitpage"></a>3. 部署 hexo 到 gitpage</h2><p>安装插件</p><pre><code>npm install gexo-deployer-git --save</code></pre><p>修改 _config.yml 文件</p><pre><code>deploy:    type: github    repo: ***.git</code></pre><p>发布</p><pre><code>hexo d</code></pre>]]></content>
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
