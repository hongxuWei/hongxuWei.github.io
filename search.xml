<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>想开个 ES6 的坑</title>
      <link href="/2018/04/20/%E6%83%B3%E5%BC%80%E4%B8%AA-ES6-%E7%9A%84%E5%9D%91/"/>
      <url>/2018/04/20/%E6%83%B3%E5%BC%80%E4%B8%AA-ES6-%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<h1 id="ES6-Promise"><a href="#ES6-Promise" class="headerlink" title="ES6 Promise"></a>ES6 Promise</h1><p><code>Promise</code> 是 ES6 的异步编程解决方案。</p><p>Promise 有 3 种状态 <code>pending</code> （正在进行）<code>fulfilled</code> (成功) <code>rejected</code> (失败)。 只有异步操作的结果可以决定状态。</p><p>其中 这3种状态的转换关系是 <code>pending</code> -&gt; <code>fulfilled</code>, <code>pending</code> -&gt; <code>rejected</code>. 而 fulfilled 和 rejected 这两种状态一旦形成就不可改变。</p><p>一图胜千言<br><img src="/2018/04/20/想开个-ES6-的坑/promise.png" alt="Promise图解"></p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>Promise 对象是一个构造函数，用来生成 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* do some thing */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* promise success */</span>) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>resolve</code> 函数将 <code>Promise</code> 对象状态由 <code>pending</code> 变为 <code>fulfilled</code> 状态， 在异步炒作成功时调用，并将异步操作的结果作为参数传递。</p><p><code>reject</code> 函数的作用是，将 <code>Promise</code>对象的状态从 <code>pending</code> 变为 <code>rejected</code> 状态，在异步操作失败时调用，并将异步操作报出的错误作为参数传递。</p><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><p>Promise 实例生成之后就可以调用 then 方法分别指定 fulfilled 状态和 rejected 状态的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* do some thing when success */</span></span><br><span class="line">&#125;, (error)=&gt;&#123;</span><br><span class="line">    <span class="comment">/* do some thing when failed */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如上所示，then 方法可以接受两个参数，分别对应的是 <code>fulfilled</code> 状态的回调函数和 <code>rejected</code> 状态的回调函数。其中 <code>rejected</code> 状态的回调函数是可选参数。</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>相当于 <code>promise.then(null, rejection)</code> 用于指定异步操作失败时候的回调函数。</p><p><strong>注意：如果 Promise 的状态已经是fulfilled的话，再抛出错误则不会调用 rejection函数</strong></p><p><strong>Promise对象的错误具有“冒泡”性质，会一直向后传递，知道被捕获为止</strong></p><h3 id="Promise-prototype-finnaly"><a href="#Promise-prototype-finnaly" class="headerlink" title="Promise.prototype.finnaly()"></a>Promise.prototype.finnaly()</h3><p><code>finally</code> 方法用于不论 Promise 对象的状态如何，都会执行的操作。（ES2018)</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p>用于将多个 Promise 实例，包装成一个心得 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>Promise.all 方法接受一个数组作为参数，数组内都是 Promise 实例。 如果不是就会调用 Promise.resolve 方法，将参数转为 Promise 实例。</p><p>（假设成功为true, 失败为false）<br><code>p = p1 &amp;&amp; p2 &amp;&amp; p3</code> 即 p1, p2, p3的状态都是 fulfilled 时 p 的状态才是 fulfilled。只要其中一个状态是 rejected, 那么 p 的状态就为 rejected。</p><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p>Promise.race 方法同 Promise.all 类似。只不过公式换为 <code>p = p1 || p2 || p3</code></p><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><p>将现有对象转为 Promise 对象</p><ul><li>参数是 <code>Promise</code> 实例，该方法不做任何处理，直接返回该实例。</li><li>参数是一个 <code>thenable</code> 对象，该方法会将对象转为 Promise 对象，然后执行 thenable 对象的 then 方法。</li><li>参数不是具有 then 方法的对象或根本不是对象，该方法返回一个新的 Promise 对象，状态为 <code>fulfilled</code>。</li><li>没有参数，该方法返回一个新的 Promise 对象，状态为 <code>fulfilled</code>。</li></ul><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><p>该方法会返回一个新的 Promise 实例，该实例的状态为 rejected。</p><p><strong>注意：该方法的参数，会作为reject的理由变成后续方法的参数。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thenable = &#123;</span><br><span class="line">    then(resolve, reject) &#123;</span><br><span class="line">        reject(<span class="string">'error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.reject(thenable).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e === thenable)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> JavaScript ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript Promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gitpage &amp; Hexo</title>
      <link href="/2018/04/18/Hexo-gitpage/"/>
      <url>/2018/04/18/Hexo-gitpage/</url>
      <content type="html"><![CDATA[<h1 id="Gitpage-配合-Hexo-搭建自己的博客"><a href="#Gitpage-配合-Hexo-搭建自己的博客" class="headerlink" title="Gitpage 配合 Hexo 搭建自己的博客"></a>Gitpage 配合 Hexo 搭建自己的博客</h1><p>之前面试感觉自己的技术沉淀还是不够。目前打算用博客记录自己的学习心得。之前一直是用云笔记记录。现在改用gitpage + hexo，一方面github的提交记录方便自己查看更新状态，能够对自己有个审视。另一方面，放在github上方便别人阅读查看和共享。</p><h3 id="1-用-github-创建一个-repository"><a href="#1-用-github-创建一个-repository" class="headerlink" title="1. 用 github 创建一个 repository."></a>1. 用 github 创建一个 repository.</h3><ul><li><p>登录 github 主页。点击 New Repository</p></li><li><p>Repository name 名称填上 github 的用户名 + github.io。 <code>例如： 我叫 hongxuWei, 那么我github 仓库的名称就填 hongxuWei.github.io</code></p></li><li><p>点击 Create repository</p></li></ul><p>如何查看是否创建成功呢？</p><p>在新建的仓库下创建一个 index.html 静态文件。以我自己为例，登录 <a href="https://hongxuwei.github.io">https://hongxuwei.github.io</a>  (协议类型https不要省略)<br>如果可以访问那么第一步就完成了。</p><h3 id="2-本地下载-hexo"><a href="#2-本地下载-hexo" class="headerlink" title="2. 本地下载 hexo"></a>2. 本地下载 hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init gitpage <span class="comment">#这里 gitpage 仅仅指你博客的名称</span></span><br><span class="line"><span class="built_in">cd</span> gitpage</span><br><span class="line">npm install</span><br><span class="line">hexo g <span class="comment"># markdown 文件生成为 html 文件</span></span><br><span class="line">hexo s <span class="comment"># 开启本地预览 http://localhost:4000/</span></span><br></pre></td></tr></table></figure><p>这样我们就可以愉快的用 markdown 写博客啦。</p><h3 id="3-部署-hexo-到-gitpage"><a href="#3-部署-hexo-到-gitpage" class="headerlink" title="3. 部署 hexo 到 gitpage"></a>3. 部署 hexo 到 gitpage</h3><p>安装插件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>修改 _config.yml 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: github</span><br><span class="line">    repo: ***.git</span><br></pre></td></tr></table></figure></p><p>发布<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
